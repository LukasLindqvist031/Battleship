This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-04T18:27:40.420Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitattributes
.gitignore
ActionNavigator.cs
Attack.cs
Battleship.csproj
Battleship.sln
Cell.cs
Computer.cs
GameController.cs
GameDisplay.cs
GameSetup.cs
Grid.cs
Human.cs
IDisplay.cs
IMenu.cs
IntelligentShooting.cs
IPlayerAction.cs
IShipPlacement.cs
IShootingStrategy.cs
MenuItem.cs
Player.cs
Program.cs
RandomShooting.cs
Repair.cs
Ship.cs
ShipPlacementService.cs
SimpleMenu.cs
TextPresentation.cs
UserRepairing.cs
UserShooting.cs

================================================================
Repository Files
================================================================

================
File: .gitattributes
================
###############################################################################
# Set default behavior to automatically normalize line endings.
###############################################################################
* text=auto

###############################################################################
# Set default behavior for command prompt diff.
#
# This is need for earlier builds of msysgit that does not have it on by
# default for csharp files.
# Note: This is only used by command line
###############################################################################
#*.cs     diff=csharp

###############################################################################
# Set the merge driver for project and solution files
#
# Merging from the command prompt will add diff markers to the files if there
# are conflicts (Merging from VS is not affected by the settings below, in VS
# the diff markers are never inserted). Diff markers may cause the following 
# file extensions to fail to load in VS. An alternative would be to treat
# these files as binary and thus will always conflict and require user
# intervention with every merge. To do so, just uncomment the entries below
###############################################################################
#*.sln       merge=binary
#*.csproj    merge=binary
#*.vbproj    merge=binary
#*.vcxproj   merge=binary
#*.vcproj    merge=binary
#*.dbproj    merge=binary
#*.fsproj    merge=binary
#*.lsproj    merge=binary
#*.wixproj   merge=binary
#*.modelproj merge=binary
#*.sqlproj   merge=binary
#*.wwaproj   merge=binary

###############################################################################
# behavior for image files
#
# image files are treated as binary by default.
###############################################################################
#*.jpg   binary
#*.png   binary
#*.gif   binary

###############################################################################
# diff behavior for common document formats
# 
# Convert binary document formats to text before diffing them. This feature
# is only available from the command line. Turn it on by uncommenting the 
# entries below.
###############################################################################
#*.doc   diff=astextplain
#*.DOC   diff=astextplain
#*.docx  diff=astextplain
#*.DOCX  diff=astextplain
#*.dot   diff=astextplain
#*.DOT   diff=astextplain
#*.pdf   diff=astextplain
#*.PDF   diff=astextplain
#*.rtf   diff=astextplain
#*.RTF   diff=astextplain

================
File: .gitignore
================
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Oo]ut/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd

================
File: ActionNavigator.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    // KRAV #1:
    // 1: Generics
    // 2: ActionNavigator<T> tillåter navigering för vilken menytyp som helst, som IShootingStrategy eller IPlayerAction.
    // 3: Genom att använda generics kan ActionNavigator återanvändas för olika menytyper i spelet.
    public class ActionNavigator<T>
    {
        private readonly SimpleMenu<T> _menu;

        public ActionNavigator(SimpleMenu<T> menu)
        {
            _menu = menu;
        }

        public T Navigate()
        {
            while (true)
            {
                _menu.Draw();
                var input = Console.ReadKey(true);
                switch (input.Key)
                {
                    case ConsoleKey.UpArrow:
                        _menu.Up();
                        break;
                    case ConsoleKey.DownArrow:
                        _menu.Down();
                        break;
                    case ConsoleKey.Enter:
                        return _menu.GetSelectedItem();
                    default:
                        Console.WriteLine("Invalid key. Use arrows to navigate and Enter to select.");
                        break;
                }
            }
        }
    }
}

================
File: Attack.cs
================
using System;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Attack : IPlayerAction
    {
        public string Name { get; } = "Attack";

        private Grid _opponentGrid;
        //private Cell _targetCell; //Används aldrig?

        public Attack(Grid opponentGrid)
        {
            _opponentGrid = opponentGrid;
        }

        public void Execute(Player player, Cell targetCell)
        {
            targetCell.IsHit = true;

            if (!targetCell.IsEmpty())
            {
                Ship targetShip = targetCell.Ship;
                if (targetShip != null)
                {
                    targetShip.HitTaken++;
                    targetCell.WasRepaired = false;  // Reset repair status on a new hit to be able to repair the same cell multiple times.

                    if (targetShip.IsSunk())
                    {
                        player.RemoveSunkShip(targetShip);
                    }
                }
            }
        }
    }
}

================
File: Battleship.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

================
File: Battleship.sln
================
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.11.35327.3
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Battleship", "Battleship.csproj", "{19741242-26BF-494E-A93F-0B645421CDD1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{19741242-26BF-494E-A93F-0B645421CDD1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{19741242-26BF-494E-A93F-0B645421CDD1}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{19741242-26BF-494E-A93F-0B645421CDD1}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{19741242-26BF-494E-A93F-0B645421CDD1}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {52D39088-333C-4BDA-A01B-1E8E1872AA0D}
	EndGlobalSection
EndGlobal

================
File: Cell.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Cell
    {
        public int Row { get; set; }
        public int Column { get; set; }
        public Ship Ship { get; set; } //Refers to a ship if there is one.
        public bool IsHit { get; set; } //Checks to see if the cell has been hit.
        public bool WasRepaired { get; set; } = false;

        public Cell(int row, int column)
        {
            Row = row;
            Column = column;
            IsHit = false;
        }

        public bool IsEmpty() //Method to check if the cell is empty (no ship).
        {
            return Ship == null;
        }

        public bool HasShip() {  return Ship != null; }
    }
}

================
File: Computer.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Computer : Player
    {
        public Computer(
            string name,
            Grid playerGrid,
            Grid opponentGrid,
            List<Ship> ships,
            List<IPlayerAction> actions,
            IShootingStrategy shootingStrategy
             )
            : base(name, playerGrid, opponentGrid, ships, actions, shootingStrategy)
        {
        }
    }
}

================
File: GameController.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class GameController
    {
        private readonly Player _humanPlayer;
        private readonly Player _computerPlayer;
        private readonly IDisplay _display;
        private Player _currentPlayer;
        private bool _isGameOver = false;

        public GameController(Player humanPlayer, Player computerPlayer, IDisplay display)
        {
            _humanPlayer = humanPlayer;
            _computerPlayer = computerPlayer;
            _display = display;
            _currentPlayer = humanPlayer;
        }

        public Player GetCurrentPlayer()
        {
            return _currentPlayer;
        }

        public Player GetOpponent()
        {
            return _currentPlayer == _humanPlayer ? _computerPlayer : _humanPlayer;
        }

        public bool CheckGameOver()
        {
            bool humanShipsDestroyed = _humanPlayer.AreAllShipsSunk();
            bool computerShipsDestroyed = _computerPlayer.AreAllShipsSunk();

            if (humanShipsDestroyed || computerShipsDestroyed)
            {
                _currentPlayer = humanShipsDestroyed ? _computerPlayer : _humanPlayer; // Set winner as current player
                _isGameOver = true;
                return true;
            }

            return false;
        }

        public void SwitchPlayer()
        {
            _currentPlayer = (_currentPlayer == _humanPlayer) ? _computerPlayer : _humanPlayer;
        }
    }
}

================
File: GameDisplay.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class GameDisplay : IDisplay
    {
        public void DrawGrid(Grid playerGrid, Grid opponentGrid, bool hideShips)
        {
            int gridWidth = 23; // Width of one grid (10 columns * 2 chars + borders)
            int totalWidth = gridWidth * 2 + 5; // Two grids plus spacing
            int gridHeight = Grid.GridSize + 1; // Grid size plus header

            // Calculate starting positions
            int startY = TextPresentation.GetCenterY(gridHeight);
            int startX = TextPresentation.GetCenterX(totalWidth);

            // Get the current player's name from the grid's associated player
            string playerName = playerGrid.Player?.Name ?? "Player";
            string opponentName = opponentGrid.Player?.Name ?? "Opponent";

            // Draw header with player names
            TextPresentation.WriteCenteredText($"{playerName}'s Grid".PadRight(25) + $"{opponentName}'s Grid", startY - 2);

            // Draw column numbers
            string colNumbers = "  0 1 2 3 4 5 6 7 8 9";
            Console.SetCursorPosition(startX, startY);
            Console.Write(colNumbers.PadRight(25));
            Console.Write(colNumbers);

            // Draw grids
            for (int row = 0; row < Grid.GridSize; row++)
            {
                Console.SetCursorPosition(startX, startY + row + 1);

                // Player grid
                Console.Write($"{row} ");
                for (int col = 0; col < Grid.GridSize; col++)
                {
                    char playerSymbol = GetCellSymbol(playerGrid.Grids[row, col], false);
                    Console.Write($"{playerSymbol} ");
                }

                Console.Write("   ");

                // Opponent grid
                Console.Write($"{row} ");
                for (int col = 0; col < Grid.GridSize; col++)
                {
                    char opponentSymbol = GetCellSymbol(opponentGrid.Grids[row, col], hideShips);
                    Console.Write($"{opponentSymbol} ");
                }
            }
        }

        private char GetCellSymbol(Cell cell, bool hideShips)
        {
            if (cell.IsHit && cell.HasShip()) return 'X';
            if (cell.IsHit && cell.IsEmpty()) return 'M';
            if (!cell.IsHit && cell.HasShip() && !hideShips) return 'O';
            if (!cell.IsHit && cell.IsEmpty()) return '~';
            return '~';
        }
    }
}

================
File: GameSetup.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class GameSetup
    {
        private readonly ShipPlacementService _shipPlacementService;
        private readonly IDisplay _display;
        private GameController _gameController;

        public GameSetup(IDisplay display)
        {
            _shipPlacementService = new ShipPlacementService();
            _display = display;
        }

        private void DisplayWelcome()
        {
            TextPresentation.WriteCenteredTextWithDelay("Welcome to Battleship!");
            Console.ReadLine();
            Console.Clear();
        }

        public string GetPlayerName()
        {
            TextPresentation.WriteCenteredTextWithDelay("Enter your name:", 50, leaveCursorBelow: true);
            string name = Console.ReadLine()?.Trim() ?? "Player";
            Console.Clear();

            return string.IsNullOrEmpty(name) ? "Player" : name;
        }

        private IShootingStrategy SelectComputerStrategy()
        {
            var centerY = Console.WindowHeight / 2;
            TextPresentation.WriteCenteredTextWithDelay("Select the computer's strategy:", 50, yPos: centerY);

            var strategies = new List<MenuItem<IShootingStrategy>>
            {
                new("Random Strategy", new RandomShooting()),
                new("Intelligent Strategy", new IntelligentShooting())
            };

            // Position the menu directly below the text
            var strategyMenu = new SimpleMenu<IShootingStrategy>(strategies, specificY: centerY + 1);
            var navigator = new ActionNavigator<IShootingStrategy>(strategyMenu);

            return navigator.Navigate();
        }

        public void Run()
        {
            DisplayWelcome();
            string playerName = GetPlayerName();
            IShootingStrategy computerStrategy = SelectComputerStrategy();

            Grid playerGrid = new Grid();
            Grid computerGrid = new Grid();

            var playerActions = new List<IPlayerAction> { new Attack(computerGrid), new Repair() };
            var computerActions = new List<IPlayerAction> { new Attack(playerGrid), new Repair() };

            Ship[] ships = { new Ship(5), new Ship(4), new Ship(3), new Ship(2), new Ship(1) };
            _shipPlacementService.PlaceShipRandomly(playerGrid, ships);
            _shipPlacementService.PlaceShipRandomly(computerGrid, ships.Select(s => s.Clone()).ToArray());

            var human = new Human(playerName, playerGrid, computerGrid, ships.ToList(), playerActions, new UserShooting());
            var computer = new Computer("Computer", computerGrid, playerGrid, ships.Select(s => s.Clone()).ToList(), computerActions, computerStrategy);

            // Set the Player property for each grid
            playerGrid.Player = human;

            var gameController = new GameController(human, computer, _display);
            RunGameLoop(gameController);
        }

        private void RunGameLoop(GameController gameController)
        {
            bool gameOver = false;
            Player lastPlayer = null; //To be able to use the name in the Game Over announcement

            Console.Clear();
            TextPresentation.WriteCenteredTextWithDelay("Deploying fleet...");
            Thread.Sleep(2000);
            while (!gameOver)
            {
                Player currentPlayer = gameController.GetCurrentPlayer();
                Console.Clear();

                if (currentPlayer is Human)
                {
                    DisplayGameState(currentPlayer, gameController);
                    HandleHumanTurn(currentPlayer);
                    System.Threading.Thread.Sleep(1500);
                }
                else if (currentPlayer is Computer)
                {
                    HandleComputerTurn(currentPlayer);
                    System.Threading.Thread.Sleep(1500); // Brief pause for transition
                }

                gameOver = gameController.CheckGameOver();
                lastPlayer = currentPlayer; //To be able to use the name in the Game Over announcement
                gameController.SwitchPlayer();
            }

            Console.Clear();
            TextPresentation.WriteCenteredTextWithDelay("Game Over!", yPos: (Console.WindowHeight / 2) - 1); 
            TextPresentation.WriteCenteredTextWithDelay($"{lastPlayer.Name} is the winner!", yPos: (Console.WindowHeight / 2) + 1);
            Console.ReadLine();
        }

        private void DisplayGameState(Player player, GameController gameController)
        {
            _display.DrawGrid(player.PlayerGrid, player.OpponentGrid, hideShips: true);
        }

        private void HandleHumanTurn(Player currentPlayer)
        {
            var menuItem = new List<MenuItem<IPlayerAction>>
            {
                new("Attack", currentPlayer.Actions[0]),
                new("Repair", currentPlayer.Actions[1])
            };

            var menu = new SimpleMenu<IPlayerAction>(menuItem, belowGrid: true);
            bool validAction = false;

            while (!validAction)
            {
                menu.Draw();

                var key = Console.ReadKey(true);
                switch (key.Key)
                {
                    case ConsoleKey.UpArrow:
                        menu.Up();
                        break;
                    case ConsoleKey.DownArrow:
                        menu.Down();
                        break;
                    case ConsoleKey.Enter:
                        var selectedItem = menu.GetSelectedItem();
                        var action = selectedItem;

                        if (action is Attack attack)
                        {
                            currentPlayer.ShootingStrategy.Shoot(currentPlayer);
                            validAction = true;
                        }
                        else if (action is Repair repair)
                        {
                            UserRepairing userRepair = new UserRepairing();
                            bool repairSuccess = userRepair.HandleRepair(currentPlayer);
                            validAction = repairSuccess;
                        }
                        break;
                }
            }
        }


        private void HandleComputerTurn(Player computerPlayer)
        {
            var random = new Random();

            var damagedCells = computerPlayer.PlayerGrid.Grids
                .Cast<Cell>()
                .Where(cell => cell.IsHit && cell.Ship != null && !cell.Ship.IsSunk())
                .ToList();

            bool shouldRepair = random.Next(1, 101) <= 30 && damagedCells.Any();

            if (shouldRepair)
            {
                var repairAction = computerPlayer.Actions.OfType<Repair>().FirstOrDefault();
                if (repairAction != null)
                {
                    Cell targetCell = damagedCells[random.Next(damagedCells.Count)];
                    repairAction.Execute(computerPlayer, targetCell);
                    TextPresentation.WriteCenteredText($"{computerPlayer.Name} chose to repair a damaged cell at ({targetCell.Row}), ({targetCell.Column}).");
                    Thread.Sleep(1500); // Give time to read the message
                }
            }
            else
            {
                computerPlayer.ShootingStrategy?.Shoot(computerPlayer);
                TextPresentation.WriteCenteredText($"{computerPlayer.Name} has completed its turn by shooting.");
                Thread.Sleep(1500); // Give time to read the message
            }
        }
    }
}

================
File: Grid.cs
================
using System;
using System.Collections;
using System.Collections.Generic;

namespace Battleship
{
    public class Grid : IEnumerable<Cell>
    {
        public const int GridSize = 10;
        public Cell[,] Grids { get; set; }
        public Player Player { get; set; }  // Added Player property

        public Grid()
        {
            Grids = new Cell[GridSize, GridSize];
            for (int row = 0; row < GridSize; row++)
            {
                for (int col = 0; col < GridSize; col++)
                {
                    Grids[row, col] = new Cell(row, col);
                }
            }
        }

        public IEnumerator<Cell> GetEnumerator()
        {
            return new GridEnumerator(this);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        private class GridEnumerator : IEnumerator<Cell>
        {
            private readonly Grid _grid;
            private int _currentRow;
            private int _currentCol;
            private bool _start;

            public GridEnumerator(Grid grid)
            {
                _grid = grid;
                _currentRow = 0;
                _currentCol = -1;
                _start = true;
            }

            public Cell Current
            {
                get
                {
                    if (_currentCol < 0 || _currentRow >= GridSize)
                        throw new InvalidOperationException();
                    return _grid.Grids[_currentRow, _currentCol];
                }
            }

            object IEnumerator.Current => Current;

            public bool MoveNext()
            {
                if (_start)
                {
                    _currentCol = 0;
                    _start = false;
                    return true;
                }

                _currentCol++;
                if (_currentCol >= GridSize)
                {
                    _currentCol = 0;
                    _currentRow++;
                }

                return _currentRow < GridSize;
            }

            public void Reset()
            {
                _currentRow = 0;
                _currentCol = -1;
                _start = true;
            }

            public void Dispose()
            {
            }
        }
    }
}

================
File: Human.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Human : Player
    {
        public Human(
            string name,
            Grid playerGrid,
            Grid opponentGrid,
            List<Ship> ships,
            List<IPlayerAction> actions,
            IShootingStrategy shootingStrategy
            )
            : base(name, playerGrid, opponentGrid, ships, actions, shootingStrategy)
        {
        }
    }
}

================
File: IDisplay.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IDisplay
    {
        void DrawGrid(Grid playerGrid, Grid opponentGrid, bool hideShips);
    }
}

================
File: IMenu.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IMenu<T>
    {
        void Draw();
        void Up();
        void Down();
        T GetSelectedItem();
    }
}

================
File: IntelligentShooting.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class IntelligentShooting : IShootingStrategy
    {
        private readonly Random _random;
        private List<Cell> _hitCells;
        private readonly Queue<Cell> _possibleTargets;

        public IntelligentShooting()
        {
            _random = new Random();
            _hitCells = new List<Cell>();
            _possibleTargets = new Queue<Cell>();
        }
        public void Shoot(Player player)
        {
            Grid opponentGrid = player.OpponentGrid;

            if (_possibleTargets.Count > 0)
            {
                Cell targetCell = _possibleTargets.Dequeue();

                if (targetCell.IsHit)
                {
                    Shoot(player);
                    return;
                }
                ExecuteAttack(player, targetCell);
            }
            else
            {
                Cell targetCell = IsValidShoot(opponentGrid);
                ExecuteAttack(player, targetCell);
            }
        }
        private void ExecuteAttack(Player player, Cell targetCell)
        {
            Attack attack = new Attack(player.OpponentGrid);
            attack.Execute(player, targetCell);

            if (!targetCell.IsEmpty() && targetCell.IsHit)
            {
                _hitCells.Add(targetCell);
                AddAdjacentCellsToTargets(player.OpponentGrid, targetCell);
            }
        }

        private void AddAdjacentCellsToTargets(Grid opponentGrid, Cell cell)
        {
            int row = cell.Row;
            int col = cell.Column;

            if (row > 0 && !opponentGrid.Grids[row - 1, col].IsHit)
                _possibleTargets.Enqueue(opponentGrid.Grids[row - 1, col]);

            if (row < Grid.GridSize - 1 && !opponentGrid.Grids[row + 1, col].IsHit)
                _possibleTargets.Enqueue(opponentGrid.Grids[row + 1, col]);

            if (col > 0 && !opponentGrid.Grids[row, col - 1].IsHit)
                _possibleTargets.Enqueue(opponentGrid.Grids[row, col - 1]);

            if (col < Grid.GridSize - 1 && !opponentGrid.Grids[row, col + 1].IsHit)
                _possibleTargets.Enqueue(opponentGrid.Grids[row, col + 1]);
        }
        private Cell IsValidShoot(Grid opponentGrid)
        {
            Cell targetCell;
            int row, col;

            do
            {
                row = _random.Next(0, Grid.GridSize);
                col = _random.Next(0, Grid.GridSize);
                targetCell = opponentGrid.Grids[row, col];
            }
            while (targetCell.IsHit);

            return targetCell;
        }
    }
}

================
File: IPlayerAction.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IPlayerAction
    {
        string Name { get; }
        void Execute(Player player, Cell targetCell); 
    }
}

================
File: IShipPlacement.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IShipPlacement
    {
        void PlaceShipRandomly(Grid grid, Ship[] ship);
    }
}

================
File: IShootingStrategy.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    // KRAV #2:
    // 1: Strategy pattern
    // 2: Implementeringar av IShootingStrategy låter datorn använda olika strategier som väljs under körning.
    // 3: Detta ger flexibilitet, då olika spelstilar kan användas genom att ändra strategi utan att behöva ändra datorns logik.
    public interface IShootingStrategy
    {
        void Shoot(Player player);
    }
}

================
File: MenuItem.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class MenuItem<T>
    {
        public string Text { get; }
        public T Value { get; }
        public bool IsSelected { get; set; }

        public MenuItem(string text, T value)
        {
            Text = text;
            Value = value;
            IsSelected = false;
        }
    }
}

================
File: Player.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    // KRAV #3:
    // 1: Bridge Pattern
    // 2: Player-abstraktionen samarbetar med IShootingStrategy-abstraktionen, och spelet sätter ihop dessa typer för att skapa olika spelarbeteenden.
    // 3: Bridge Pattern separerar hierarkierna Player och ShootingStrategy, vilket främjar modularitet och olika strategier.
    public abstract class Player 
    {
        public string Name { get; }
        public Grid PlayerGrid { get; }
        public Grid OpponentGrid { get; }
        public List<Ship> Ships { get; }
        public List<IPlayerAction> Actions { get; }
        public IShootingStrategy ShootingStrategy { get; }


        protected Player(
        string name,
        Grid playerGrid,
        Grid opponentGrid,
        List<Ship> ships,
        List<IPlayerAction> actions,
        IShootingStrategy shootingStrategy
        )
        {
            Name = name;
            PlayerGrid = playerGrid;
            OpponentGrid = opponentGrid;
            Ships = ships;
            Actions = new List<IPlayerAction> { new Attack(opponentGrid), new Repair() };
            ShootingStrategy = shootingStrategy;
            
        }
        public void RemoveSunkShip(Ship ship)
        {
            if (Ships.Contains(ship)) {  Ships.Remove(ship); }
        }

        public bool AreAllShipsSunk()
        {
            return !PlayerGrid.Any(cell => cell.HasShip() && !cell.IsHit);
        }
    }
}

================
File: Program.cs
================
using Battleship;

IDisplay display = new GameDisplay();

GameSetup game = new GameSetup(display);
game.Run();

================
File: RandomShooting.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class RandomShooting : IShootingStrategy
    {
        private readonly Random _random;

        public RandomShooting()
        {
            _random = new Random();
        }

        public void Shoot(Player player)
        {
            Grid opponentGrid = player.OpponentGrid;

            Cell targetCell = IsValidShoot(opponentGrid);

            Attack attack = new Attack(opponentGrid);
            attack.Execute(player, targetCell);
        }

        public Cell IsValidShoot(Grid opponentGrid)
        {
            Cell targetCell;
            int row, col;

            do
            {
                row = _random.Next(0, Grid.GridSize);
                col = _random.Next(0, Grid.GridSize);
                targetCell = opponentGrid.Grids[row, col];
            }
            while (targetCell.IsHit);

            return targetCell;
        }
    }
}

================
File: Repair.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Repair : IPlayerAction
    {
        public string Name { get; } = "Repair";

        public bool AttemptRepair(Player player)
        {
            foreach (var cell in player.PlayerGrid)
            {
                if (cell.IsHit && cell.HasShip())
                {
                    return true;
                }
            }
            return false;
        }

        public void Execute(Player player, Cell targetCell)
        {
            if (targetCell != null && targetCell.IsHit)
            {
                targetCell.IsHit = false;
                targetCell.WasRepaired = true;
                Ship associatedShip = targetCell.Ship;

                if (associatedShip != null)
                {
                    associatedShip.HitTaken = Math.Max(0, associatedShip.HitTaken - 1);

                    // Re-evaluate if the ship was previously marked as sunk
                    if (associatedShip.IsSunk() && !player.Ships.Contains(associatedShip))
                    {
                        player.Ships.Add(associatedShip);
                    }
                }
            }
        }

    }
}

================
File: Ship.cs
================
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace Battleship
{
    public class Ship
    {
        public int Length { get; set; }
        public List<Cell> PlacedOnCell { get; set; }
        public int HitTaken { get; set; }

        public Ship(int length)
        {
            Length = length;
            PlacedOnCell = new List<Cell>();
            HitTaken = 0; 
        }

        public bool IsSunk()
        {
            return HitTaken >= Length;
        }
        public Ship Clone()
        {
            return new Ship(Length);
        }
    }
}

================
File: ShipPlacementService.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.ExceptionServices;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    // KRAV #5:
    // 1: LINQ
    // 2: LINQ querys hjälper till att identifiera tillgängliga celler för skeppsplacering genom att filtrera och verifiera cellisolering.
    // 3: LINQ förenklar logiken, vilket gör koden lättare att läsa.
    public class ShipPlacementService : IShipPlacement
    {
        public void PlaceShipRandomly(Grid grid, Ship[] ships)
        {
            Random random = new Random();
            foreach (Ship ship in ships)
            {
                bool placed = false;
                while (!placed)
                {
                    var availableCells = grid.Where(cell => cell.IsEmpty()).ToList();
                    if (availableCells.Count == 0) break;

                    Cell startCell = availableCells[random.Next(availableCells.Count)];
                    placed = TryPlaceShip(grid, startCell, ship, random.Next(2) == 0);
                }
            }
        }
        private bool TryPlaceShip(Grid grid, Cell startCell, Ship ship, bool horizontal) //LINQ-kravet
        {
            var shipCells = horizontal
                ? grid.Where(c => c.Row == startCell.Row &&
                                c.Column >= startCell.Column &&
                                c.Column < startCell.Column + ship.Length)
                : grid.Where(c => c.Column == startCell.Column &&
                                c.Row >= startCell.Row &&
                                c.Row < startCell.Row + ship.Length);

            if (shipCells.Count() != ship.Length || shipCells.Any(c => !c.IsEmpty() || !IsCellIsolated(grid, c.Row, c.Column)))
                return false;

            foreach (var cell in shipCells)
            {
                cell.Ship = ship;
            }
            return true;
        }

        private bool IsCellIsolated(Grid grid, int row, int col)
        {
            var neighbors = grid.Where(cell =>
                (cell.Row == row - 1 && cell.Column == col) ||
                (cell.Row == row + 1 && cell.Column == col) ||
                (cell.Row == row && cell.Column == col - 1) ||
                (cell.Row == row && cell.Column == col + 1));

            return neighbors.All(cell => cell.IsEmpty());
        }

    }
}

================
File: SimpleMenu.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class SimpleMenu<T> : IMenu<T>
    {
        private readonly List<MenuItem<T>> MenuItems;
        private int SelectedIndex;
        private readonly int MenuTop;
        private readonly int MenuLeft;
        private readonly bool BelowGrid;

        public SimpleMenu(List<MenuItem<T>> items, bool belowGrid = false, int? specificY = null)
        {
            MenuItems = items;
            SelectedIndex = 0;
            BelowGrid = belowGrid;

            // Calculate menu dimensions
            int menuWidth = items.Max(item => item.Text.Length) + 4; // +4 for arrow and padding
            int menuHeight = items.Count;

            if (specificY.HasValue)
            {
                // Use specific Y position when provided
                MenuTop = specificY.Value;
                MenuLeft = TextPresentation.GetCenterX(menuWidth);
            }
            else if (belowGrid)
            {
                // Position menu below the player's grid (left side)
                MenuTop = (Console.WindowHeight / 2) + 6;
                MenuLeft = TextPresentation.GetCenterX(menuWidth * 2) - menuWidth * 2 + 2; // Align with player grid
            }
            else
            {
                // Original centered positioning
                MenuTop = TextPresentation.GetCenterY(menuHeight);
                MenuLeft = TextPresentation.GetCenterX(menuWidth);
            }
        }

        public void Draw()
        {
            Console.CursorVisible = false;

            // Clear menu area
            for (int i = 0; i < MenuItems.Count; i++)
            {
                Console.SetCursorPosition(MenuLeft, MenuTop + i);
                Console.Write(new string(' ', MenuItems[i].Text.Length + 4));
            }

            // Draw menu items
            for (int i = 0; i < MenuItems.Count; i++)
            {
                Console.SetCursorPosition(MenuLeft, MenuTop + i);
                if (i == SelectedIndex)
                {
                    Console.Write($"-> {MenuItems[i].Text}");
                }
                else
                {
                    Console.Write($"   {MenuItems[i].Text}");
                }
            }
        }

        public void Up()
        {
            if (SelectedIndex > 0)
            {
                MenuItems[SelectedIndex].IsSelected = false;
                SelectedIndex--;
                MenuItems[SelectedIndex].IsSelected = true;
                Draw();
            }
        }

        public void Down()
        {
            if (SelectedIndex < MenuItems.Count - 1)
            {
                MenuItems[SelectedIndex].IsSelected = false;
                SelectedIndex++;
                MenuItems[SelectedIndex].IsSelected = true;
                Draw();
            }
        }

        public T GetSelectedItem()
        {
            return MenuItems[SelectedIndex].Value;
        }
    }
}

================
File: TextPresentation.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public static class TextPresentation
    {
        public static void WriteCenteredTextWithDelay(string text, int delay = 50, bool leaveCursorBelow = false, int? yPos = null)
        {
            int consoleWidth = Console.WindowWidth;
            int consoleHeight = Console.WindowHeight;

            int xPos = (consoleWidth - text.Length) / 2;
            int yPosition = yPos ?? consoleHeight / 2;

            Console.CursorVisible = false;
            Console.SetCursorPosition(xPos, yPosition);

            foreach (char c in text)
            {
                Console.Write(c);
                Thread.Sleep(delay);
            }

            if (leaveCursorBelow)
            {
                Console.SetCursorPosition(xPos, yPosition + 1);
            }
        }

        public static void WriteCenteredText(string text, int? yPos = null)
        {
            int consoleWidth = Console.WindowWidth;
            int consoleHeight = Console.WindowHeight;

            int xPos = (consoleWidth - text.Length) / 2;
            int yPosition = yPos ?? consoleHeight / 2;

            Console.SetCursorPosition(xPos, yPosition);
            Console.Write(text);
        }

        public static int GetCenterX(int contentWidth)
        {
            return (Console.WindowWidth - contentWidth) / 2;
        }

        public static int GetCenterY(int contentHeight)
        {
            return (Console.WindowHeight - contentHeight) / 2;
        }
    }

}

================
File: UserRepairing.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class UserRepairing
    {
        public bool HandleRepair(Player humanPlayer)
        {
            // Get a list of damaged cells
            var damagedCells = humanPlayer.PlayerGrid.Grids
                .Cast<Cell>()
                .Where(cell => cell.IsHit && cell.Ship != null && !cell.Ship.IsSunk())
                .ToList();

            // Check if there are any damaged cells
            if (!damagedCells.Any())
            {
                Console.WriteLine("No damaged ships to repair. Choose another action.");
                return false; // Return false if there are no damaged ships
            }

            // Prompt the user for coordinates to repair a damaged cell
            while (true)
            {
                Console.WriteLine("Enter the coordinates of the cell you want to repair:");
                Cell targetCell = GetValidTargetFromUser(humanPlayer.PlayerGrid);

                // Check if the selected cell is part of the damaged cells
                if (damagedCells.Contains(targetCell))
                {
                    var repairAction = humanPlayer.Actions.OfType<Repair>().FirstOrDefault();
                    if (repairAction != null)
                    {
                        repairAction.Execute(humanPlayer, targetCell);
                        Console.WriteLine($"Repaired ship at ({targetCell.Row}, {targetCell.Column}).");
                        return true; // Return true after a successful repair
                    }
                }
                else
                {
                    // Notify the user that the selected cell is not damaged
                    Console.WriteLine("The selected cell is not damaged. Please choose a damaged cell.");
                }
            }
        }

        private Cell GetValidTargetFromUser(Grid playerGrid)
        {
            while (true)
            {
                Console.Write($"Row (0-{Grid.GridSize - 1}): ");
                if (!int.TryParse(Console.ReadLine(), out int row) || row < 0 || row >= Grid.GridSize)
                {
                    Console.WriteLine($"Invalid row number. Please enter a number between 0 and {Grid.GridSize - 1}.");
                    continue;
                }

                Console.Write($"Column (0-{Grid.GridSize - 1}): ");
                if (!int.TryParse(Console.ReadLine(), out int col) || col < 0 || col >= Grid.GridSize)
                {
                    Console.WriteLine($"Invalid column number. Please enter a number between 0 and {Grid.GridSize - 1}.");
                    continue;
                }

                return playerGrid.Grids[row, col];
            }
        }
    }
}

================
File: UserShooting.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class UserShooting : IShootingStrategy
    {
        public void Shoot(Player player)
        {
            Grid opponentGrid = player.OpponentGrid;
            Cell targetCell = GetValidTargetFromUser(opponentGrid);

            if (targetCell != null)
            {
                Attack attack = new Attack(opponentGrid);
                attack.Execute(player, targetCell);

                if (targetCell.HasShip())
                {
                    Console.WriteLine("Hit! You've struck an enemy ship!");
                    if (targetCell.Ship.IsSunk())
                    {
                        Console.WriteLine($"You've sunk a ship of length {targetCell.Ship.Length}!");
                    }
                }
                else
                {
                    Console.WriteLine("Miss! You hit the water.");
                }
                System.Threading.Thread.Sleep(1500);
            }
        }

        private Cell GetValidTargetFromUser(Grid opponentGrid)
        {
            // Starting position for input prompts
            int inputLineY = Console.WindowHeight / 2 + 8;

            // Row input
            int row;
            while (true)
            {
                Console.SetCursorPosition(0, inputLineY);
                Console.Write(new string(' ', Console.WindowWidth)); // Clear line
                Console.SetCursorPosition(0, inputLineY);
                Console.Write($"Row (0-{Grid.GridSize - 1}): ");
                if (int.TryParse(Console.ReadLine(), out row) && row >= 0 && row < Grid.GridSize)
                {
                    break; // Valid row entered
                }

                // Display error for invalid row input
                Console.SetCursorPosition(0, inputLineY + 1);
                Console.Write(new string(' ', Console.WindowWidth)); // Clear line
                Console.SetCursorPosition(0, inputLineY + 1);
                Console.WriteLine($"Invalid row. Enter a number between 0 and {Grid.GridSize - 1}.");
            }

            // Column input
            int col;
            while (true)
            {
                Console.SetCursorPosition(0, inputLineY + 2);
                Console.Write(new string(' ', Console.WindowWidth)); // Clear line
                Console.SetCursorPosition(0, inputLineY + 2);
                Console.Write($"Column (0-{Grid.GridSize - 1}): ");
                if (int.TryParse(Console.ReadLine(), out col) && col >= 0 && col < Grid.GridSize)
                {
                    break; // Valid column entered
                }

                // Display error for invalid column input
                Console.SetCursorPosition(0, inputLineY + 3);
                Console.Write(new string(' ', Console.WindowWidth)); // Clear line
                Console.SetCursorPosition(0, inputLineY + 3);
                Console.WriteLine($"Invalid column. Enter a number between 0 and {Grid.GridSize - 1}.");
            }

            // Validate chosen cell
            Cell targetCell = opponentGrid.Grids[row, col];
            if (targetCell.IsHit)
            {
                Console.SetCursorPosition(0, inputLineY + 4);
                Console.Write(new string(' ', Console.WindowWidth)); // Clear line
                Console.SetCursorPosition(0, inputLineY + 4);
                Console.WriteLine("This cell has already been targeted. Please choose another location.");

                // Recursively call the method for a new selection
                return GetValidTargetFromUser(opponentGrid);
            }

            // Clear any lingering error messages before returning the valid cell
            Console.SetCursorPosition(0, inputLineY + 4);
            Console.Write(new string(' ', Console.WindowWidth));

            return targetCell;
        }

    }
}
