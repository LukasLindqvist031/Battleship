================
File: ActionNavigator.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    // KRAV #1:
    // 1: Generics
    // 2: ActionNavigator<T> tillåter navigering för vilken menytyp som helst, som IShootingStrategy eller IPlayerAction.
    // 3: Genom att använda generics kan ActionNavigator återanvändas för olika menytyper i spelet.
    public class ActionNavigator<T>
    {
        private readonly SimpleMenu<T> _menu;

        public ActionNavigator(SimpleMenu<T> menu)
        {
            _menu = menu;
        }

        public T Navigate()
        {
            while (true)
            {
                _menu.Draw();
                var input = Console.ReadKey(true);
                switch (input.Key)
                {
                    case ConsoleKey.UpArrow:
                        _menu.Up();
                        break;
                    case ConsoleKey.DownArrow:
                        _menu.Down();
                        break;
                    case ConsoleKey.Enter:
                        return _menu.GetSelectedItem();
                    default:
                        Console.WriteLine("Invalid key. Use arrows to navigate and Enter to select.");
                        break;
                }
            }
        }
    }
}

================
File: Attack.cs
================
using System;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Attack : IPlayerAction
    {
        public string Name { get; } = "Attack";

        private Grid _opponentGrid;
        //private Cell _targetCell; //Används aldrig?

        public Attack(Grid opponentGrid)
        {
            _opponentGrid = opponentGrid;
        }

        public void Execute(Player player, Cell targetCell)
        {
            targetCell.IsHit = true;

            if (!targetCell.IsEmpty())
            {
                Ship targetShip = targetCell.Ship;
                if (targetShip != null)
                {
                    targetShip.HitTaken++;
                    targetCell.WasRepaired = false;  // Reset repair status on a new hit to be able to repair the same cell multiple times.

                    if (targetShip.IsSunk())
                    {
                        player.RemoveSunkShip(targetShip);
                    }
                }
            }
        }
    }
}

================
File: Cell.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Cell
    {
        public int Row { get; set; }
        public int Column { get; set; }
        public Ship Ship { get; set; } //Refers to a ship if there is one.
        public bool IsHit { get; set; } //Checks to see if the cell has been hit.
        public bool WasRepaired { get; set; } = false;

        public Cell(int row, int column)
        {
            Row = row;
            Column = column;
            IsHit = false;
        }

        public bool IsEmpty() //Method to check if the cell is empty (no ship).
        {
            return Ship == null;
        }

        public bool HasShip() {  return Ship != null; }
    }
}

================
File: Computer.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Computer : Player
    {
        public Computer(
            string name,
            Grid playerGrid,
            Grid opponentGrid,
            List<Ship> ships,
            List<IPlayerAction> actions,
            IShootingStrategy shootingStrategy
             )
            : base(name, playerGrid, opponentGrid, ships, actions, shootingStrategy)
        {
        }
    }
}

================
File: GameController.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class GameController
    {
        private readonly Player _humanPlayer;
        private readonly Player _computerPlayer;
        private readonly IDisplay _display;
        private Player _currentPlayer;
        private bool _isGameOver = false;

        public GameController(Player humanPlayer, Player computerPlayer, IDisplay display)
        {
            _humanPlayer = humanPlayer;
            _computerPlayer = computerPlayer;
            _display = display;
            _currentPlayer = humanPlayer;
        }

        public Player GetCurrentPlayer()
        {
            return _currentPlayer;
        }

        public Player GetOpponent()
        {
            return _currentPlayer == _humanPlayer ? _computerPlayer : _humanPlayer;
        }

        public bool CheckGameOver()
        {
            bool humanShipsDestroyed = _humanPlayer.AreAllShipsSunk();
            bool computerShipsDestroyed = _computerPlayer.AreAllShipsSunk();

            if (humanShipsDestroyed || computerShipsDestroyed)
            {
                _currentPlayer = humanShipsDestroyed ? _computerPlayer : _humanPlayer; // Set winner as current player
                _isGameOver = true;
                return true;
            }

            return false;
        }

        public void SwitchPlayer()
        {
            _currentPlayer = (_currentPlayer == _humanPlayer) ? _computerPlayer : _humanPlayer;
        }
    }
}

================
File: GameDisplay.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class GameDisplay : IDisplay
    {
        public void DrawGrid(Grid playerGrid, Grid opponentGrid, bool hideShips)
        {
            int gridWidth = 23; // Width of one grid (10 columns * 2 chars + borders)
            int totalWidth = gridWidth * 2 + 5; // Two grids plus spacing
            int gridHeight = Grid.GridSize + 1; // Grid size plus header

            // Calculate starting positions
            int startY = TextPresentation.GetCenterY(gridHeight);
            int startX = TextPresentation.GetCenterX(totalWidth);

            // Draw header
            TextPresentation.WriteCenteredText("Your Grid".PadRight(25) + "Opponent's Grid", startY - 2);

            // Draw column numbers
            string colNumbers = "  0 1 2 3 4 5 6 7 8 9";
            Console.SetCursorPosition(startX, startY);
            Console.Write(colNumbers.PadRight(25));
            Console.Write(colNumbers);

            // Draw grids
            for (int row = 0; row < Grid.GridSize; row++)
            {
                Console.SetCursorPosition(startX, startY + row + 1);

                // Player grid
                Console.Write($"{row} ");
                for (int col = 0; col < Grid.GridSize; col++)
                {
                    char playerSymbol = GetCellSymbol(playerGrid.Grids[row, col], false);
                    Console.Write($"{playerSymbol} ");
                }

                Console.Write("   ");

                // Opponent grid
                Console.Write($"{row} ");
                for (int col = 0; col < Grid.GridSize; col++)
                {
                    char opponentSymbol = GetCellSymbol(opponentGrid.Grids[row, col], hideShips);
                    Console.Write($"{opponentSymbol} ");
                }
            }
        }

        private char GetCellSymbol(Cell cell, bool hideShips)
        {
            if (cell.IsHit && cell.HasShip()) return 'X';
            if (cell.IsHit && cell.IsEmpty()) return 'M';
            if (!cell.IsHit && cell.HasShip() && !hideShips) return 'O';
            if (!cell.IsHit && cell.IsEmpty()) return '~';
            return '~';
        }
    }
}

================
File: GameSetup.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class GameSetup
    {
        private readonly ShipPlacementService _shipPlacementService;
        private readonly IDisplay _display;
        private GameController _gameController;

        public GameSetup(IDisplay display)
        {
            _shipPlacementService = new ShipPlacementService();
            _display = display;
        }

        private void DisplayWelcome()
        {
            TextPresentation.WriteCenteredTextWithDelay("Welcome to Battleship!");
            Console.ReadLine();
            Console.Clear();
        }

        public string GetPlayerName()
        {
            TextPresentation.WriteCenteredTextWithDelay("Enter your name:", 50, leaveCursorBelow: true);
            string name = Console.ReadLine()?.Trim() ?? "Player";
            Console.Clear();

            return string.IsNullOrEmpty(name) ? "Player" : name;
        }

        private IShootingStrategy SelectComputerStrategy()
        {
            var centerY = Console.WindowHeight / 2;
            TextPresentation.WriteCenteredTextWithDelay("Select the computer's strategy:", 50, yPos: centerY);

            var strategies = new List<MenuItem<IShootingStrategy>>
            {
                new("Random Strategy", new RandomShooting()),
                new("Intelligent Strategy", new IntelligentShooting())
            };

            // Position the menu directly below the text
            var strategyMenu = new SimpleMenu<IShootingStrategy>(strategies, specificY: centerY + 1);
            var navigator = new ActionNavigator<IShootingStrategy>(strategyMenu);

            return navigator.Navigate();
        }

        public void Run()
        {
            DisplayWelcome();
            string playerName = GetPlayerName();
            IShootingStrategy computerStrategy = SelectComputerStrategy();

            Grid playerGrid = new Grid();
            Grid computerGrid = new Grid();

            var playerActions = new List<IPlayerAction> { new Attack(computerGrid), new Repair() };
            var computerActions = new List<IPlayerAction> { new Attack(playerGrid), new Repair() };

            Ship[] ships = { new Ship(5), new Ship(4), new Ship(3), new Ship(2), new Ship(1) };
            _shipPlacementService.PlaceShipRandomly(playerGrid, ships);
            _shipPlacementService.PlaceShipRandomly(computerGrid, ships.Select(s => s.Clone()).ToArray());

            var human = new Human(playerName, playerGrid, computerGrid, ships.ToList(), playerActions, new UserShooting());
            var computer = new Computer("Computer", computerGrid, playerGrid, ships.Select(s => s.Clone()).ToList(), computerActions, computerStrategy);

            var gameController = new GameController(human, computer, _display);
            RunGameLoop(gameController);
        }

        private void RunGameLoop(GameController gameController)
        {
            bool gameOver = false;
            Player lastPlayer = null; //To be able to use the name in the Game Over announcement

            Console.Clear();
            TextPresentation.WriteCenteredTextWithDelay("Deploying fleet...");
            Thread.Sleep(2000);
            while (!gameOver)
            {
                Player currentPlayer = gameController.GetCurrentPlayer();
                Console.Clear();

                if (currentPlayer is Human)
                {
                    DisplayGameState(currentPlayer, gameController);
                    HandleHumanTurn(currentPlayer);
                }
                else if (currentPlayer is Computer)
                {
                    HandleComputerTurn(currentPlayer);
                    System.Threading.Thread.Sleep(1500); // Brief pause for transition
                }

                gameOver = gameController.CheckGameOver();
                lastPlayer = currentPlayer; //To be able to use the name in the Game Over announcement
                gameController.SwitchPlayer();
            }

            Console.Clear();
            TextPresentation.WriteCenteredTextWithDelay("Game Over!", yPos: (Console.WindowHeight / 2) - 1); 
            TextPresentation.WriteCenteredTextWithDelay($"{lastPlayer.Name} is the winner!", yPos: (Console.WindowHeight / 2) + 1);
            Console.ReadLine();
        }

        private void DisplayGameState(Player player, GameController gameController)
        {
            //Console.WriteLine($"{player.Name}'s Grid:".PadRight(25) + $"{gameController.GetOpponent().Name}'s Grid:");
            _display.DrawGrid(player.PlayerGrid, player.OpponentGrid, hideShips: true);
        }

        private void HandleHumanTurn(Player currentPlayer)
        {
            var menuItem = new List<MenuItem<IPlayerAction>>
        {
            new("Attack", currentPlayer.Actions[0]),
            new("Repair", currentPlayer.Actions[1])
        };

            var menu = new SimpleMenu<IPlayerAction>(menuItem, belowGrid: true);
            bool validAction = false;

            while (!validAction)
            {
                Console.Clear();
                DisplayGameState(currentPlayer, _gameController);
                menu.Draw();

                var key = Console.ReadKey(true);
                switch (key.Key)
                {
                    case ConsoleKey.UpArrow:
                        menu.Up();
                        break;
                    case ConsoleKey.DownArrow:
                        menu.Down();
                        break;
                    case ConsoleKey.Enter:
                        var selectedItem = menu.GetSelectedItem();
                        var action = selectedItem;

                        if (action is Attack attack)
                        {
                            currentPlayer.ShootingStrategy.Shoot(currentPlayer);
                            validAction = true;
                        }
                        else if (action is Repair repair)
                        {
                            if (repair.AttemptRepair(currentPlayer))
                            {
                                Cell targetCell;
                                bool validCell = false;

                                while (!validCell)
                                {
                                    Console.SetCursorPosition(0, Console.WindowHeight / 2 + 9);
                                    Console.WriteLine("Enter coordinates of the cell to repair:");

                                    Console.Write("Row (0-" + (Grid.GridSize - 1) + "): ");
                                    int row = int.Parse(Console.ReadLine() ?? "0");

                                    Console.Write("Column (0-" + (Grid.GridSize - 1) + "): ");
                                    int col = int.Parse(Console.ReadLine() ?? "0");

                                    if (row >= 0 && row < Grid.GridSize && col >= 0 && col < Grid.GridSize)
                                    {
                                        targetCell = currentPlayer.PlayerGrid.Grids[row, col];

                                        if (targetCell.IsHit)
                                        {
                                            repair.Execute(currentPlayer, targetCell);
                                            validCell = true;
                                            validAction = true;
                                        }
                                        else
                                        {
                                            Console.WriteLine("This cell is not damaged. Please choose a damaged cell.");
                                        }
                                    }
                                    else
                                    {
                                        Console.WriteLine("Invalid coordinates. Please enter coordinates within the grid.");
                                    }
                                }
                            }
                            else
                            {
                                Console.WriteLine("No damaged ships to repair. Please choose another action.");
                            }
                        }
                        break;
                }
            }
        }



        private void HandleComputerTurn(Player computerPlayer)
        {
            var random = new Random();

            var damagedCells = computerPlayer.PlayerGrid.Grids
                .Cast<Cell>()
                .Where(cell => cell.IsHit && cell.Ship != null && !cell.Ship.IsSunk())
                .ToList();

            if (!damagedCells.Any())
            {
                computerPlayer.ShootingStrategy?.Shoot(computerPlayer);
                TextPresentation.WriteCenteredText($"{computerPlayer.Name} has completed its turn by shooting.");
                return;
            }

            bool shouldRepair = random.Next(1, 101) <= 30;

            if (shouldRepair)
            {
                var repairAction = computerPlayer.Actions.OfType<Repair>().FirstOrDefault();

                if (repairAction != null)
                {
                    Cell targetCell = damagedCells[random.Next(damagedCells.Count)];
                    repairAction.Execute(computerPlayer, targetCell);
                    TextPresentation.WriteCenteredText($"{computerPlayer.Name} chose to repair a damaged cell at ({targetCell.Row}), ({targetCell.Column}).");
                }
                else
                {
                    computerPlayer.ShootingStrategy?.Shoot(computerPlayer);
                    Console.WriteLine($"{computerPlayer.Name} has completed its turn by shooting.");
                }
            }
        }
    }
}

================
File: Grid.cs
================
using System;
using System.Collections;
using System.Collections.Generic;

namespace Battleship
{
    // KRAV #4:
    // 1: Iterator Pattern
    // 2: Den anpassade GridEnumerator itererar över alla celler.
    // 3: Detta gör Grid-strukturen kompatibel med LINQ och möjliggör flexibla speloperationer.
    public class Grid : IEnumerable<Cell>
    {
        public const int GridSize = 10;
        public Cell[,] Grids { get; set; }

        public Grid()
        {
            Grids = new Cell[GridSize, GridSize];
            for (int row = 0; row < GridSize; row++)
            {
                for (int col = 0; col < GridSize; col++)
                {
                    Grids[row, col] = new Cell(row, col);
                }
            }
        }
        public IEnumerator<Cell> GetEnumerator()
        {
            return new GridEnumerator(this);
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
        private class GridEnumerator : IEnumerator<Cell>
        {
            private readonly Grid _grid;
            private int _currentRow;
            private int _currentCol;
            private bool _start;

            public GridEnumerator(Grid grid)
            {
                _grid = grid;
                _currentRow = 0;
                _currentCol = -1;
                _start = true;
            }

            public Cell Current
            {
                get
                {
                    if (_currentCol < 0 || _currentRow >= GridSize)
                        throw new InvalidOperationException();
                    return _grid.Grids[_currentRow, _currentCol];
                }
            }

            object IEnumerator.Current => Current;

            public bool MoveNext()
            {
                if (_start)
                {
                    _currentCol = 0;
                    _start = false;
                    return true;
                }

                _currentCol++;
                if (_currentCol >= GridSize)
                {
                    _currentCol = 0;
                    _currentRow++;
                }

                return _currentRow < GridSize;
            }
            public void Reset()
            {
                _currentRow = 0;
                _currentCol = -1;
                _start = true;
            }
            public void Dispose()
            {
            }
        }
    }
}

================
File: Human.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Human : Player
    {
        public Human(
            string name,
            Grid playerGrid,
            Grid opponentGrid,
            List<Ship> ships,
            List<IPlayerAction> actions,
            IShootingStrategy shootingStrategy
            )
            : base(name, playerGrid, opponentGrid, ships, actions, shootingStrategy)
        {
        }
    }
}

================
File: IDisplay.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IDisplay
    {
        void DrawGrid(Grid playerGrid, Grid opponentGrid, bool hideShips);
    }
}

================
File: IMenu.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IMenu<T>
    {
        void Draw();
        void Up();
        void Down();
        T GetSelectedItem();
    }
}

================
File: IntelligentShooting.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class IntelligentShooting : IShootingStrategy
    {
        private readonly Random _random;
        private List<Cell> _hitCells;
        private readonly Queue<Cell> _possibleTargets;

        public IntelligentShooting()
        {
            _random = new Random();
            _hitCells = new List<Cell>();
            _possibleTargets = new Queue<Cell>();
        }
        public void Shoot(Player player)
        {
            Grid opponentGrid = player.OpponentGrid;

            if (_possibleTargets.Count > 0)
            {
                Cell targetCell = _possibleTargets.Dequeue();

                if (targetCell.IsHit)
                {
                    Shoot(player);
                    return;
                }
                ExecuteAttack(player, targetCell);
            }
            else
            {
                Cell targetCell = IsValidShoot(opponentGrid);
                ExecuteAttack(player, targetCell);
            }
        }
        private void ExecuteAttack(Player player, Cell targetCell)
        {
            Attack attack = new Attack(player.OpponentGrid);
            attack.Execute(player, targetCell);

            if (!targetCell.IsEmpty() && targetCell.IsHit)
            {
                _hitCells.Add(targetCell);
                AddAdjacentCellsToTargets(player.OpponentGrid, targetCell);
            }
        }

        private void AddAdjacentCellsToTargets(Grid opponentGrid, Cell cell)
        {
            int row = cell.Row;
            int col = cell.Column;

            if (row > 0 && !opponentGrid.Grids[row - 1, col].IsHit)
                _possibleTargets.Enqueue(opponentGrid.Grids[row - 1, col]);

            if (row < Grid.GridSize - 1 && !opponentGrid.Grids[row + 1, col].IsHit)
                _possibleTargets.Enqueue(opponentGrid.Grids[row + 1, col]);

            if (col > 0 && !opponentGrid.Grids[row, col - 1].IsHit)
                _possibleTargets.Enqueue(opponentGrid.Grids[row, col - 1]);

            if (col < Grid.GridSize - 1 && !opponentGrid.Grids[row, col + 1].IsHit)
                _possibleTargets.Enqueue(opponentGrid.Grids[row, col + 1]);
        }
        private Cell IsValidShoot(Grid opponentGrid)
        {
            Cell targetCell;
            int row, col;

            do
            {
                row = _random.Next(0, Grid.GridSize);
                col = _random.Next(0, Grid.GridSize);
                targetCell = opponentGrid.Grids[row, col];
            }
            while (targetCell.IsHit);

            return targetCell;
        }
    }
}

================
File: IPlayerAction.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IPlayerAction
    {
        string Name { get; }
        void Execute(Player player, Cell targetCell); 
    }
}

================
File: IShipPlacement.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IShipPlacement
    {
        void PlaceShipRandomly(Grid grid, Ship[] ship);
    }
}

================
File: IShootingStrategy.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    // KRAV #2:
    // 1: Strategy pattern
    // 2: Implementeringar av IShootingStrategy låter datorn använda olika strategier som väljs under körning.
    // 3: Detta ger flexibilitet, då olika spelstilar kan användas genom att ändra strategi utan att behöva ändra datorns logik.
    public interface IShootingStrategy
    {
        void Shoot(Player player);
    }
}

================
File: MenuItem.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class MenuItem<T>
    {
        public string Text { get; }
        public T Value { get; }
        public bool IsSelected { get; set; }

        public MenuItem(string text, T value)
        {
            Text = text;
            Value = value;
            IsSelected = false;
        }
    }
}

================
File: Player.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    // KRAV #3:
    // 1: Bridge Pattern
    // 2: Player-abstraktionen samarbetar med IShootingStrategy-abstraktionen, och spelet sätter ihop dessa typer för att skapa olika spelarbeteenden.
    // 3: Bridge Pattern separerar hierarkierna Player och ShootingStrategy, vilket främjar modularitet och olika strategier.
    public abstract class Player 
    {
        public string Name { get; }
        public Grid PlayerGrid { get; }
        public Grid OpponentGrid { get; }
        public List<Ship> Ships { get; }
        public List<IPlayerAction> Actions { get; }
        public IShootingStrategy ShootingStrategy { get; }


        protected Player(
        string name,
        Grid playerGrid,
        Grid opponentGrid,
        List<Ship> ships,
        List<IPlayerAction> actions,
        IShootingStrategy shootingStrategy
        )
        {
            Name = name;
            PlayerGrid = playerGrid;
            OpponentGrid = opponentGrid;
            Ships = ships;
            Actions = new List<IPlayerAction> { new Attack(opponentGrid), new Repair() };
            ShootingStrategy = shootingStrategy;
            
        }
        public void RemoveSunkShip(Ship ship)
        {
            if (Ships.Contains(ship)) {  Ships.Remove(ship); }
        }

        public bool AreAllShipsSunk()
        {
            return !PlayerGrid.Any(cell => cell.HasShip() && !cell.IsHit);
        }
    }
}

================
File: Program.cs
================
using Battleship;

IDisplay display = new GameDisplay();

GameSetup game = new GameSetup(display);
game.Run();

================
File: RandomShooting.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class RandomShooting : IShootingStrategy
    {
        private readonly Random _random;

        public RandomShooting()
        {
            _random = new Random();
        }

        public void Shoot(Player player)
        {
            Grid opponentGrid = player.OpponentGrid;

            Cell targetCell = IsValidShoot(opponentGrid);

            Attack attack = new Attack(opponentGrid);
            attack.Execute(player, targetCell);
        }

        public Cell IsValidShoot(Grid opponentGrid)
        {
            Cell targetCell;
            int row, col;

            do
            {
                row = _random.Next(0, Grid.GridSize);
                col = _random.Next(0, Grid.GridSize);
                targetCell = opponentGrid.Grids[row, col];
            }
            while (targetCell.IsHit);

            return targetCell;
        }
    }
}

================
File: Repair.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Repair : IPlayerAction
    {
        public string Name { get; } = "Repair";

        public bool AttemptRepair(Player player)
        {
            foreach (var cell in player.PlayerGrid)
            {
                if (cell.IsHit && cell.HasShip())
                {
                    return true;
                }
            }
            return false;
        }

        public void Execute(Player player, Cell targetCell)
        {
            if (targetCell != null && targetCell.IsHit)
            {
                targetCell.IsHit = false;
                targetCell.WasRepaired = true;
                Ship associatedShip = targetCell.Ship;

                if (associatedShip != null && associatedShip.HitTaken > 0)
                {
                    associatedShip.HitTaken--;
                }
            }
        }

    }
}

================
File: Ship.cs
================
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace Battleship
{
    public class Ship
    {
        public int Length { get; set; }
        public List<Cell> PlacedOnCell { get; set; }
        public int HitTaken { get; set; }

        public Ship(int length)
        {
            Length = length;
            PlacedOnCell = new List<Cell>();
            HitTaken = 0; 
        }

        public bool IsSunk()
        {
            return HitTaken >= Length;
        }
        public Ship Clone()
        {
            return new Ship(Length);
        }
    }
}

================
File: ShipPlacementService.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.ExceptionServices;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    // KRAV #5:
    // 1: LINQ
    // 2: LINQ querys hjälper till att identifiera tillgängliga celler för skeppsplacering genom att filtrera och verifiera cellisolering.
    // 3: LINQ förenklar logiken, vilket gör koden lättare att läsa.
    public class ShipPlacementService : IShipPlacement
    {
        public void PlaceShipRandomly(Grid grid, Ship[] ships)
        {
            Random random = new Random();
            foreach (Ship ship in ships)
            {
                bool placed = false;
                while (!placed)
                {
                    var availableCells = grid.Where(cell => cell.IsEmpty()).ToList();
                    if (availableCells.Count == 0) break;

                    Cell startCell = availableCells[random.Next(availableCells.Count)];
                    placed = TryPlaceShip(grid, startCell, ship, random.Next(2) == 0);
                }
            }
        }
        private bool TryPlaceShip(Grid grid, Cell startCell, Ship ship, bool horizontal) //LINQ-kravet
        {
            var shipCells = horizontal
                ? grid.Where(c => c.Row == startCell.Row &&
                                c.Column >= startCell.Column &&
                                c.Column < startCell.Column + ship.Length)
                : grid.Where(c => c.Column == startCell.Column &&
                                c.Row >= startCell.Row &&
                                c.Row < startCell.Row + ship.Length);

            if (shipCells.Count() != ship.Length || shipCells.Any(c => !c.IsEmpty() || !IsCellIsolated(grid, c.Row, c.Column)))
                return false;

            foreach (var cell in shipCells)
            {
                cell.Ship = ship;
            }
            return true;
        }

        private bool IsCellIsolated(Grid grid, int row, int col)
        {
            var neighbors = grid.Where(cell =>
                (cell.Row == row - 1 && cell.Column == col) ||
                (cell.Row == row + 1 && cell.Column == col) ||
                (cell.Row == row && cell.Column == col - 1) ||
                (cell.Row == row && cell.Column == col + 1));

            return neighbors.All(cell => cell.IsEmpty());
        }

    }
}

================
File: SimpleMenu.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class SimpleMenu<T> : IMenu<T>
    {
        private readonly List<MenuItem<T>> MenuItems;
        private int SelectedIndex;
        private readonly int MenuTop;
        private readonly int MenuLeft;
        private readonly bool BelowGrid;

        public SimpleMenu(List<MenuItem<T>> items, bool belowGrid = false, int? specificY = null)
        {
            MenuItems = items;
            SelectedIndex = 0;
            BelowGrid = belowGrid;

            // Calculate menu dimensions
            int menuWidth = items.Max(item => item.Text.Length) + 4; // +4 for arrow and padding
            int menuHeight = items.Count;

            if (specificY.HasValue)
            {
                // Use specific Y position when provided
                MenuTop = specificY.Value;
                MenuLeft = TextPresentation.GetCenterX(menuWidth);
            }
            else if (belowGrid)
            {
                // Position menu below the player's grid (left side)
                MenuTop = (Console.WindowHeight / 2) + 6;
                MenuLeft = TextPresentation.GetCenterX(menuWidth * 2) - menuWidth * 2 + 2; // Align with player grid
            }
            else
            {
                // Original centered positioning
                MenuTop = TextPresentation.GetCenterY(menuHeight);
                MenuLeft = TextPresentation.GetCenterX(menuWidth);
            }
        }

        public void Draw()
        {
            Console.CursorVisible = false;

            // Clear menu area
            for (int i = 0; i < MenuItems.Count; i++)
            {
                Console.SetCursorPosition(MenuLeft, MenuTop + i);
                Console.Write(new string(' ', MenuItems[i].Text.Length + 4));
            }

            // Draw menu items
            for (int i = 0; i < MenuItems.Count; i++)
            {
                Console.SetCursorPosition(MenuLeft, MenuTop + i);
                if (i == SelectedIndex)
                {
                    Console.Write($"-> {MenuItems[i].Text}");
                }
                else
                {
                    Console.Write($"   {MenuItems[i].Text}");
                }
            }
        }

        public void Up()
        {
            if (SelectedIndex > 0)
            {
                MenuItems[SelectedIndex].IsSelected = false;
                SelectedIndex--;
                MenuItems[SelectedIndex].IsSelected = true;
                Draw();
            }
        }

        public void Down()
        {
            if (SelectedIndex < MenuItems.Count - 1)
            {
                MenuItems[SelectedIndex].IsSelected = false;
                SelectedIndex++;
                MenuItems[SelectedIndex].IsSelected = true;
                Draw();
            }
        }

        public T GetSelectedItem()
        {
            return MenuItems[SelectedIndex].Value;
        }
    }
}

================
File: TextPresentation.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public static class TextPresentation
    {
        public static void WriteCenteredTextWithDelay(string text, int delay = 50, bool leaveCursorBelow = false, int? yPos = null)
        {
            int consoleWidth = Console.WindowWidth;
            int consoleHeight = Console.WindowHeight;

            int xPos = (consoleWidth - text.Length) / 2;
            int yPosition = yPos ?? consoleHeight / 2;

            Console.CursorVisible = false;
            Console.SetCursorPosition(xPos, yPosition);

            foreach (char c in text)
            {
                Console.Write(c);
                Thread.Sleep(delay);
            }

            if (leaveCursorBelow)
            {
                Console.SetCursorPosition(xPos, yPosition + 1);
            }
        }

        public static void WriteCenteredText(string text, int? yPos = null)
        {
            int consoleWidth = Console.WindowWidth;
            int consoleHeight = Console.WindowHeight;

            int xPos = (consoleWidth - text.Length) / 2;
            int yPosition = yPos ?? consoleHeight / 2;

            Console.SetCursorPosition(xPos, yPosition);
            Console.Write(text);
        }

        public static int GetCenterX(int contentWidth)
        {
            return (Console.WindowWidth - contentWidth) / 2;
        }

        public static int GetCenterY(int contentHeight)
        {
            return (Console.WindowHeight - contentHeight) / 2;
        }
    }

}

================
File: UserShooting.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class UserShooting : IShootingStrategy
    {
        public void Shoot(Player player)
        {
            Grid opponentGrid = player.OpponentGrid;
            Cell targetCell = GetValidTargetFromUser(opponentGrid);

            if (targetCell != null)
            {
                Attack attack = new Attack(opponentGrid);
                attack.Execute(player, targetCell);

                if (targetCell.HasShip())
                {
                    Console.WriteLine("Hit! You've struck an enemy ship!");
                    if (targetCell.Ship.IsSunk())
                    {
                        Console.WriteLine($"You've sunk a ship of length {targetCell.Ship.Length}!");
                    }
                }
                else
                {
                    Console.WriteLine("Miss! You hit the water.");
                }
                System.Threading.Thread.Sleep(1500);
            }
        }

        private Cell GetValidTargetFromUser(Grid opponentGrid)
        {

            while (true)
            {

                Console.WriteLine("\nEnter target coordinates:");

                Console.Write($"Row (0-{Grid.GridSize - 1}): ");
                if (!int.TryParse(Console.ReadLine(), out int row) || row < 0 || row >= Grid.GridSize)
                {
                    Console.WriteLine("Invalid row number. Please enter a number between " + $"0 and {Grid.GridSize - 1}.");
                    continue;
                }

                Console.Write($"Column (0-{Grid.GridSize - 1}): ");
                if (!int.TryParse(Console.ReadLine(), out int col) || col < 0 || col >= Grid.GridSize)
                {
                    Console.WriteLine("Invalid column number. Please enter a number between " + $"0 and {Grid.GridSize - 1}.");
                    continue;
                }

                Cell targetCell = opponentGrid.Grids[row, col];

                if (targetCell.IsHit)
                {
                    Console.WriteLine("This cell has already been targeted. Please choose another location.");
                    continue;
                }

                return targetCell;
            }
        }
    }
}
