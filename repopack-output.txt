================
File: ActionNavigator.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class ActionNavigator<T>
    {
        private readonly SimpleMenu<T> _menu;

        public ActionNavigator(SimpleMenu<T> menu)
        {
            _menu = menu;
        }

        public T Navigate()
        {
            while (true)
            {
                _menu.Draw();
                var input = Console.ReadKey(true);
                switch (input.Key)
                {
                    case ConsoleKey.UpArrow:
                        _menu.Up();
                        break;
                    case ConsoleKey.DownArrow:
                        _menu.Down();
                        break;
                    case ConsoleKey.Enter:
                        return _menu.GetSelectedItem();
                    default:
                        Console.WriteLine("Invalid key. Use arrows to navigate and Enter to select.");
                        break;
                }
            }
        }
    }
}

================
File: Attack.cs
================
using System;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Attack : IPlayerAction
    {
        public string Name { get; } = "Attack";

        private Grid _opponentGrid;//Används aldrig?
        private Cell _targetCell; //Används aldrig?

        public Attack(Grid opponentGrid)
        {
            _opponentGrid = opponentGrid;
        }

        public void Execute(Player player, Cell targetCell)
        {
            if (targetCell == null)
            {
                Console.WriteLine("Invalid target cell.");
                return;
            }

            targetCell.IsHit = true;

            if (!targetCell.IsEmpty())
            {
                Ship targetShip = targetCell.Ship;
                if (targetShip != null)
                {
                    targetShip.HitTaken++;
                    targetCell.WasRepaired = false;  // Reset repair status on a new hit to be able to repair the same cell multiple times.

                    if (targetShip.IsSunk())
                    {
                        player.RemoveSunkShip(targetShip);
                    }
                }
            }
        }
    }
}

================
File: Battleship.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

================
File: Battleship.sln
================
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.11.35327.3
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Battleship", "Battleship.csproj", "{19741242-26BF-494E-A93F-0B645421CDD1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{19741242-26BF-494E-A93F-0B645421CDD1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{19741242-26BF-494E-A93F-0B645421CDD1}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{19741242-26BF-494E-A93F-0B645421CDD1}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{19741242-26BF-494E-A93F-0B645421CDD1}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {52D39088-333C-4BDA-A01B-1E8E1872AA0D}
	EndGlobalSection
EndGlobal

================
File: Cell.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Cell
    {
        public int Row { get; set; }
        public int Column { get; set; }
        public Ship Ship { get; set; } //Refers to a ship if there is one.
        public bool IsHit { get; set; } //Checks to see if the cell has been hit.
        public bool WasRepaired { get; set; } = false;

        public Cell(int row, int column)
        {
            Row = row;
            Column = column;
            IsHit = false;
        }

        public bool IsEmpty() //Method to check if the cell is empty (no ship).
        {
            return Ship == null;
        }

        public bool HasShip() {  return Ship != null; }
    }
}

================
File: Computer.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Computer : Player
    {
        public Computer(
            string name,
            Grid playerGrid,
            Grid opponentGrid,
            List<Ship> ships,
            List<IPlayerAction> actions,
            IShootingStrategy shootingStrategy
             )
            : base(name, playerGrid, opponentGrid, ships, actions, shootingStrategy)
        {
        }
    }
}

================
File: GameController.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class GameController
    {
        private readonly Player _humanPlayer;
        private readonly Player _computerPlayer;
        private readonly IDisplay _display;
        private Player _currentPlayer;
        private bool _isGameOver;

        public GameController(Player humanPlayer, Player computerPlayer, IDisplay display)
        {
            _humanPlayer = humanPlayer;
            _computerPlayer = computerPlayer;
            _display = display;
            _currentPlayer = humanPlayer;
            _isGameOver = false;
        }

        public Player GetCurrentPlayer()
        {
            return _currentPlayer;
        }

        public Player GetOpponent()
        {
            return _currentPlayer == _humanPlayer ? _computerPlayer : _humanPlayer;
        }

        public bool CheckGameOver()
        {
            bool humanShipsDestroyed = _humanPlayer.AreAllShipsSunk();
            bool computerShipsDestroyed = _computerPlayer.AreAllShipsSunk();

            if (humanShipsDestroyed || computerShipsDestroyed)
            {
                _currentPlayer = humanShipsDestroyed ? _computerPlayer : _humanPlayer; // Set winner as current player
                _isGameOver = true;
                return true;
            }

            return false;
        }

        public void SwitchPlayer()
        {
            _currentPlayer = (_currentPlayer == _humanPlayer) ? _computerPlayer : _humanPlayer;
        }
    }
}

================
File: GameDisplay.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class GameDisplay : IDisplay
    {
        public GameDisplay() { }

        public void ShowMessage(string message)
        {
            Console.WriteLine(message);
        }

        public void DrawGrid(Grid playerGrid, Grid opponentGrid, bool hideShips)
        {
            Console.WriteLine("  0 1 2 3 4 5 6 7 8 9   ".PadRight(25) + "  0 1 2 3 4 5 6 7 8 9");
            for (int row = 0; row < Grid.GridSize; row++)
            {
                // Display player grid row
                Console.Write($"{row} ");
                for (int col = 0; col < Grid.GridSize; col++)
                {
                    char playerSymbol = GetCellSymbol(playerGrid.Grids[row, col], false);
                    Console.Write($"{playerSymbol} ");
                }

                // Spacer between grids
                Console.Write("   ");

                // Display opponent grid row
                Console.Write($"{row} ");
                for (int col = 0; col < Grid.GridSize; col++)
                {
                    char opponentSymbol = GetCellSymbol(opponentGrid.Grids[row, col], hideShips);
                    Console.Write($"{opponentSymbol} ");
                }

                Console.WriteLine();
            }
        }

        private char GetCellSymbol(Cell cell, bool hideShips)
        {
            if (cell.IsHit && cell.HasShip()) return 'X'; // Hit ship
            if (cell.IsHit && cell.IsEmpty()) return 'M'; // Missed shot
            if (!cell.IsHit && cell.HasShip() && !hideShips) return 'O'; // Repaired ship part, visible to owner
            if (!cell.IsHit && cell.IsEmpty()) return '~'; // Water for empty, unhit cells
            return '~'; // Default to water for any remaining cases
        }
    }
}

================
File: GameSetup.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class GameSetup
    {
        private readonly ShipPlacementService _shipPlacementService;
        private readonly IDisplay _display;

        public GameSetup(IDisplay display)
        {
            _shipPlacementService = new ShipPlacementService();
            _display = display;
        }
        private string GetPlayerName()
        {
            Console.WriteLine("Welcome to Battleship!");
            Console.Write("Enter your name: ");
            string name = Console.ReadLine()?.Trim() ?? "Player";
            Console.Clear();
            return string.IsNullOrEmpty(name) ? "Player" : name;
        }

        private IShootingStrategy SelectComputerStrategy()
        {
            var strategies = new List<MenuItem<IShootingStrategy>>
        {
            new MenuItem<IShootingStrategy>("Random Strategy", new RandomShooting()),
            new MenuItem<IShootingStrategy>("Intelligent Strategy", new IntelligentShooting())
        };

            var strategyMenu = new SimpleMenu<IShootingStrategy>(strategies);
            var navigator = new ActionNavigator<IShootingStrategy>(strategyMenu);

            _display.ShowMessage("Select the computer's strategy:");
            return navigator.Navigate();
        }


        public void Run()
        {
            string playerName = GetPlayerName();
            IShootingStrategy computerStrategy = SelectComputerStrategy();

            Grid playerGrid = new Grid();
            Grid computerGrid = new Grid();

            var playerActions = new List<IPlayerAction> { new Attack(computerGrid), new Repair() };
            var computerActions = new List<IPlayerAction> { new Attack(playerGrid), new Repair() };

            Ship[] ships = { new Ship(5), new Ship(4), new Ship(3), new Ship(2), new Ship(1) };
            _shipPlacementService.PlaceShipRandomly(playerGrid, ships);
            _shipPlacementService.PlaceShipRandomly(computerGrid, ships.Select(s => s.Clone()).ToArray());

            var human = new Human(playerName, playerGrid, computerGrid, ships.ToList(), playerActions, new RandomShooting());
            var computer = new Computer("Computer", computerGrid, playerGrid, ships.Select(s => s.Clone()).ToList(), computerActions, computerStrategy);

            var gameController = new GameController(human, computer, _display);
            RunGameLoop(gameController);
        }

        private void RunGameLoop(GameController gameController)
        {
            bool gameOver = false;
            while (!gameOver)
            {
                Player currentPlayer = gameController.GetCurrentPlayer();
                Console.Clear();

                if (currentPlayer is Human)
                {
                    DisplayGameState(currentPlayer, gameController);
                    HandleHumanTurn(currentPlayer);
                }
                else if (currentPlayer is Computer)
                {
                    HandleComputerTurn(currentPlayer);
                    System.Threading.Thread.Sleep(1000); // Brief pause for transition
                }

                gameOver = gameController.CheckGameOver(); 
                gameController.SwitchPlayer();
            }

            Console.WriteLine("Game Over!");
        }
        private void DisplayGameState(Player player, GameController gameController)
        {
            Console.WriteLine($"{player.Name}'s Grid:".PadRight(25) + $"{gameController.GetOpponent().Name}'s Grid:");
            _display.DrawGrid(player.PlayerGrid, player.OpponentGrid, hideShips: true);
        }


        private void HandleHumanTurn(Player currentPlayer)
        {
            var menuItem = new List<MenuItem<IPlayerAction>>
            {
                new MenuItem<IPlayerAction>("Attack", currentPlayer.Actions[0]),
                new MenuItem<IPlayerAction>("Repair", currentPlayer.Actions[1])
            };

            var menu = new SimpleMenu<IPlayerAction>(menuItem);
            bool validAction = false;

            while (!validAction)
            {
                menu.Draw();

                var key = Console.ReadKey(true);
                switch (key.Key)
                {
                    case ConsoleKey.UpArrow:
                        menu.Up();
                        break;
                    case ConsoleKey.DownArrow:
                        menu.Down();
                        break;
                    case ConsoleKey.Enter:
                        var selectedItem = menu.GetSelectedItem();
                        var action = selectedItem;

                        if (action is Attack attack)
                        {
                            int messageRow = Console.WindowHeight - 2;
                            Console.SetCursorPosition(0, messageRow);
                            Console.Write(new string(' ', Console.WindowWidth));

                            Cell targetCell = null;
                            bool validInput = false;
                            do
                            {
                                //Console.SetCursorPosition(0, messageRow);
                                Console.WriteLine("Enter target coordinates:");

                                Console.Write("Row (0-" + (Grid.GridSize - 1) + "): ");
                                int row = int.TryParse(Console.ReadLine(), out var tempRow) ? tempRow : -1; //Better handling of invalid inputs

                                Console.Write("Column (0-" + (Grid.GridSize - 1) + "): ");
                                int col = int.TryParse(Console.ReadLine(), out var tempCol) ? tempCol : -1; //Better handling of invalid inputs

                                if (row >= 0 && row < Grid.GridSize && col >= 0 && col < Grid.GridSize)
                                {
                                    targetCell = currentPlayer.OpponentGrid.Grids[row, col];
                                    if (!targetCell.IsHit)
                                    {
                                        validInput = true;
                                    }
                                    else
                                    {
                                        Console.WriteLine("This cell has already been hit. Please enter new coordinates.");
                                        Console.SetCursorPosition(0, messageRow + 1);
                                        Console.Write(new string(' ', Console.WindowWidth));
                                    }
                                }
                                else
                                {
                                    Console.WriteLine("Invalid coordinates. Please enter values within the grid range.");
                                    Console.SetCursorPosition(0, messageRow + 1);
                                    Console.Write(new string(' ', Console.WindowWidth));
                                }

                            } while (!validInput);

                            attack.Execute(currentPlayer, targetCell);
                            validAction = true;
                        }


                        else if (action is Repair repair)
                        {
                            if (repair.AttemptRepair(currentPlayer))
                            {
                                Cell targetCell;
                                bool validCell = false;

                                while (!validCell)
                                {
                                    // Prompt for coordinates
                                    Console.WriteLine("Enter coordinates of the cell to repair:");

                                    Console.Write("Row (0-" + (Grid.GridSize - 1) + "): ");
                                    int row = int.Parse(Console.ReadLine() ?? "0");

                                    Console.Write("Column (0-" + (Grid.GridSize - 1) + "): ");
                                    int col = int.Parse(Console.ReadLine() ?? "0");

                                    // Ensure the coordinates are within grid bounds (0-based index)
                                    if (row >= 0 && row < Grid.GridSize && col >= 0 && col < Grid.GridSize)
                                    {
                                        targetCell = currentPlayer.PlayerGrid.Grids[row, col];

                                        // Check if the selected cell is part of a damaged ship
                                        if (targetCell.IsHit)
                                        {
                                            repair.Execute(currentPlayer, targetCell);
                                            validCell = true;
                                            validAction = true;
                                        }
                                        else
                                        {
                                            Console.WriteLine("This cell is not damaged. Please choose a damaged cell.");
                                        }
                                    }
                                    else
                                    {
                                        Console.WriteLine("Invalid coordinates. Please enter coordinates within the grid.");
                                    }
                                }
                            }
                            else
                            {
                                Console.SetCursorPosition(0, menu.menuTop + menu._menuItems.Count + 1);
                                Console.WriteLine("No damaged ships to repair. Please choose another action.");
                            }
                        }
                        break;
                }
            }
        }

        private void HandleComputerTurn(Player computerPlayer)
        {
            Random random = new Random();

            // Check if there are any damaged cells in non-sunk ships
            var damagedCells = computerPlayer.PlayerGrid.Grids
                .Cast<Cell>()
                .Where(cell => cell.IsHit && cell.Ship != null && !cell.Ship.IsSunk())
                .ToList();

            // If no damaged cells are found, the computer should attack
            if (!damagedCells.Any())
            {
                computerPlayer.ShootingStrategy?.Shoot(computerPlayer);
                Console.WriteLine($"{computerPlayer.Name} has completed its turn by shooting.");
                return;
            }

            // 30% chance to repair if there are damaged cells
            bool shouldRepair = random.Next(1, 101) <= 30;

            if (shouldRepair)
            {
                // Find the Repair action within the computer's actions
                var repairAction = computerPlayer.Actions.OfType<Repair>().FirstOrDefault();

                if (repairAction != null)
                {
                    // Select a random damaged cell from a non-sunk ship
                    Cell targetCell = damagedCells[random.Next(damagedCells.Count)];
                    repairAction.Execute(computerPlayer, targetCell);
                    Console.WriteLine($"{computerPlayer.Name} chose to repair a damaged cell at ({targetCell.Row}, {targetCell.Column}).");
                }
                else
                {
                    Console.WriteLine($"{computerPlayer.Name} attempted to repair but had no repair action available.");
                }
            }
            else
            {
                // If repair is not chosen, proceed with shooting
                computerPlayer.ShootingStrategy?.Shoot(computerPlayer);
                Console.WriteLine($"{computerPlayer.Name} has completed its turn by shooting.");
            }
        }
    }
}

================
File: Grid.cs
================
using System;
using System.Collections;
using System.Collections.Generic;

namespace Battleship
{
    public class Grid : IEnumerable<Cell>
    {
        public const int GridSize = 10;
        public Cell[,] Grids { get; set; }

        public Grid()
        {
            Grids = new Cell[GridSize, GridSize];
            for (int row = 0; row < GridSize; row++)
            {
                for (int col = 0; col < GridSize; col++)
                {
                    Grids[row, col] = new Cell(row, col);
                }
            }
        }

        // Implement IEnumerable<Cell>
        public IEnumerator<Cell> GetEnumerator()
        {
            return new GridEnumerator(this);
        }

        // Implement non-generic IEnumerable
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        // Custom enumerator class
        private class GridEnumerator : IEnumerator<Cell>
        {
            private readonly Grid _grid;
            private int _currentRow;
            private int _currentCol;
            private bool _start;

            public GridEnumerator(Grid grid)
            {
                _grid = grid;
                _currentRow = 0;
                _currentCol = -1; // Start before first element
                _start = true;
            }

            public Cell Current
            {
                get
                {
                    if (_currentCol < 0 || _currentRow >= GridSize)
                        throw new InvalidOperationException();
                    return _grid.Grids[_currentRow, _currentCol];
                }
            }

            object IEnumerator.Current => Current;

            public bool MoveNext()
            {
                if (_start)
                {
                    _currentCol = 0;
                    _start = false;
                    return true;
                }

                _currentCol++;
                if (_currentCol >= GridSize)
                {
                    _currentCol = 0;
                    _currentRow++;
                }

                return _currentRow < GridSize;
            }

            public void Reset()
            {
                _currentRow = 0;
                _currentCol = -1;
                _start = true;
            }

            public void Dispose()
            {
            }
        }
    }
}

================
File: Human.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Human : Player
    {
        public Human(
            string name,
            Grid playerGrid,
            Grid opponentGrid,
            List<Ship> ships,
            List<IPlayerAction> actions,
            IShootingStrategy shootingStrategy
            )
            : base(name, playerGrid, opponentGrid, ships, actions, shootingStrategy)
        {
        }
    }
}

================
File: HumanCreater.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    internal class HumanCreater
    {
    }
}

================
File: IDisplay.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IDisplay
    {
        void DrawGrid(Grid playerGrid, Grid opponentGrid, bool hideShips);
        void ShowMessage(string message);
    }
}

================
File: IMenu.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IMenu<T>
    {
        void Draw();
        void Up();
        void Down();
        T GetSelectedItem();
    }
}

================
File: IntelligentShooting.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class IntelligentShooting : IShootingStrategy
    {
        private readonly Random _random;
        private List<Cell> _hitCells;  // Lista över träffade celler
        private Queue<Cell> _possibleTargets;  // Möjliga målceller runt ett träffat skepp

        public IntelligentShooting()
        {
            _random = new Random();
            _hitCells = new List<Cell>();
            _possibleTargets = new Queue<Cell>();
        }

        public void Shoot(Player player)
        {
            // Hämta motståndarens grid
            Grid opponentGrid = player.OpponentGrid;

            // Om vi har målceller att skjuta på (närliggande celler), välj från den kön
            if (_possibleTargets.Count > 0)
            {
                Cell targetCell = _possibleTargets.Dequeue(); // Hämta nästa cell från kön (Dequeue removes and returns the object at the beginning of the Queue<Cell>).

                // Om cellen redan har blivit träffad, välj en ny cell
                if (targetCell.IsHit)
                {
                    Shoot(player); // Skjut igen
                    return;
                }

                ExecuteAttack(player, targetCell);
            }
            else
            {
                // Annars, välj en slumpmässig cell om det inte finns några närliggande mål
                Cell targetCell = IsValidShoot(opponentGrid);
                ExecuteAttack(player, targetCell);
            }
        }

        private void ExecuteAttack(Player player, Cell targetCell)
        {
            Attack attack = new Attack(player.OpponentGrid);
            attack.Execute(player, targetCell);

            if (!targetCell.IsEmpty() && targetCell.IsHit)  // Om träff på skepp
            {
                _hitCells.Add(targetCell);  // Lägg till i listan med träffar

                // Lägg till möjliga målceller (upp, ner, vänster, höger)
                AddAdjacentCellsToTargets(player.OpponentGrid, targetCell);
            }
        }

        private void AddAdjacentCellsToTargets(Grid opponentGrid, Cell cell)
        {
            int row = cell.Row;
            int col = cell.Column;

            // Lägg till de 4 närliggande cellerna om de är giltiga skottmål
            if (row > 0 && !opponentGrid.Grids[row - 1, col].IsHit) // Upp
                _possibleTargets.Enqueue(opponentGrid.Grids[row - 1, col]); //(Enqueue adds an object to the end of the Queue<Cell>).

            if (row < Grid.GridSize - 1 && !opponentGrid.Grids[row + 1, col].IsHit) // Ner
                _possibleTargets.Enqueue(opponentGrid.Grids[row + 1, col]);

            if (col > 0 && !opponentGrid.Grids[row, col - 1].IsHit) // Vänster
                _possibleTargets.Enqueue(opponentGrid.Grids[row, col - 1]);

            if (col < Grid.GridSize - 1 && !opponentGrid.Grids[row, col + 1].IsHit) // Höger
                _possibleTargets.Enqueue(opponentGrid.Grids[row, col + 1]);
        }

        // Denna metod returnerar en slumpmässig valid cell (samma som RandomShooting, kan man typ göra en egen class eller nått med denna så man slipper upprepa den?).
        private Cell IsValidShoot(Grid opponentGrid)
        {
            Cell targetCell;
            int row, col;

            do
            {
                row = _random.Next(0, Grid.GridSize);
                col = _random.Next(0, Grid.GridSize);
                targetCell = opponentGrid.Grids[row, col];
            }
            while (targetCell.IsHit);

            return targetCell;
        }
    }
}

================
File: IPlayerAction.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IPlayerAction
    {
        string Name { get; }
        void Execute(Player player, Cell targetCell); 
    }
}

================
File: IShipPlacement.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IShipPlacement
    {
        void PlaceShipRandomly(Grid grid, Ship[] ship);
    }
}

================
File: IShootingStrategy.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IShootingStrategy
    {
        void Shoot(Player player);
    }
}

================
File: MenuItem.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class MenuItem<T>
    {
        public string Text { get; }
        public T Value { get; }
        public bool IsSelected { get; set; }

        public MenuItem(string text, T value)
        {
            Text = text;
            Value = value;
            IsSelected = false;
        }
    }
}

================
File: Player.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public abstract class Player 
    {
        public string Name { get; }
        public Grid PlayerGrid { get; }
        public Grid OpponentGrid { get; }
        public List<Ship> Ships { get; }
        public List<IPlayerAction> Actions { get; }
        public IShootingStrategy ShootingStrategy { get; }


        protected Player(
        string name,
        Grid playerGrid,
        Grid opponentGrid,
        List<Ship> ships,
        List<IPlayerAction> actions,
        IShootingStrategy shootingStrategy
        )
        {
            Name = name;
            PlayerGrid = playerGrid;
            OpponentGrid = opponentGrid;
            Ships = ships;
            Actions = new List<IPlayerAction> { new Attack(opponentGrid), new Repair() };
            ShootingStrategy = shootingStrategy;
            
        }
        public void RemoveSunkShip(Ship ship)
        {
            if (Ships.Contains(ship)) {  Ships.Remove(ship); }
        }

        public bool AreAllShipsSunk()
        {
            return !PlayerGrid.Any(cell => cell.HasShip() && !cell.IsHit);
        }
        /*public void PerformAction(int actionIndex)
        {
            if (actionIndex >= 0 && actionIndex < Actions.Count)
            {
                Actions[actionIndex].Execute(this); // Execute the chosen action
            }
            else
            {
                throw new ArgumentOutOfRangeException("Invalid action index");
            }
        }

        public void PerformShooting()
        {
            ShootingStrategy.Shoot(this); // Use the injected shooting strategy
        }*/
    }
}

================
File: Program.cs
================
using Battleship;

IDisplay display = new GameDisplay();

GameSetup game = new GameSetup(display);
game.Run();

================
File: RandomShooting.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class RandomShooting : IShootingStrategy
    {
        private readonly Random _random;

        public RandomShooting()
        {
            _random = new Random();
        }

        public void Shoot(Player player)
        {
            // Get the opponent's grid
            Grid opponentGrid = player.OpponentGrid; // Assuming Player has an Opponent reference and Grid

            // Find a valid cell to shoot at
            Cell targetCell = IsValidShoot(opponentGrid);

            // Use Attack class to perform the shooting action
            Attack attack = new Attack(opponentGrid);
            attack.Execute(player, targetCell);
        }

        public Cell IsValidShoot(Grid opponentGrid)
        {
            Cell targetCell;
            int row, col;

            do
            {
                row = _random.Next(0, Grid.GridSize);
                col = _random.Next(0, Grid.GridSize);
                targetCell = opponentGrid.Grids[row, col];
            }
            while (targetCell.IsHit);

            return targetCell;
        }
    }
}

================
File: Repair.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    using System;
    using System.Linq;

    public class Repair : IPlayerAction
    {
        public string Name { get; } = "Repair";

        public bool AttemptRepair(Player player)
        {
            // Check PlayerGrid for any cells with IsHit and an associated Ship
            foreach (var cell in player.PlayerGrid)
            {
                if (cell.IsHit && cell.HasShip())
                {
                    return true;  // A damaged cell exists, so allow repair
                }
            }

            // If no damaged cells are found, return false
            return false;
        }




        public void Execute(Player player, Cell targetCell)
        {
            if (targetCell != null && targetCell.IsHit)
            {
                targetCell.IsHit = false;  // Reset the hit status to indicate repair

                // Find the ship that includes this cell and decrement its HitTaken
                foreach (var ship in player.Ships)
                {
                    if (ship.PlacedOnCell.Contains(targetCell))
                    {
                        ship.HitTaken--;  // Decrement HitTaken for the specific ship
                        targetCell.WasRepaired = true; //Mark as repaired
                        break;  // Stop after finding the correct ship
                    }
                }
            }
        }
    }
}

================
File: Ship.cs
================
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace Battleship
{
    public class Ship
    {
        public int Length { get; set; }
        public List<Cell> PlacedOnCell { get; set; }
        public int HitTaken { get; set; }

        public Ship(int length)
        {
            Length = length;
            PlacedOnCell = new List<Cell>();
            HitTaken = 0; 
        }

        public bool IsSunk()
        {
            return HitTaken >= Length;
        }

        public void TakeHit()
        {
            HitTaken++;
        }
        public Ship Clone()
        {
            return new Ship(Length);
        }
    }
}

================
File: ShipPlacementService.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.ExceptionServices;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class ShipPlacementService : IShipPlacement
    {
        private Random _random = new Random();

        public void PlaceShipRandomly(Grid grid, Ship[] ships)
        {
            Random random = new Random();
            foreach (Ship ship in ships)
            {
                bool placed = false;
                while (!placed)
                {
                    // Get random starting position
                    var availableCells = grid.Where(cell => cell.IsEmpty()).ToList();
                    if (availableCells.Count == 0) break;

                    Cell startCell = availableCells[random.Next(availableCells.Count)];
                    placed = TryPlaceShip(grid, startCell, ship, random.Next(2) == 0);
                }
            }
        }

        private bool TryPlaceShip(Grid grid, Cell startCell, Ship ship, bool horizontal)
        {
            // Identify potential ship cells based on the starting cell and orientation
            var shipCells = horizontal
                ? grid.Where(c => c.Row == startCell.Row &&
                                c.Column >= startCell.Column &&
                                c.Column < startCell.Column + ship.Length)
                : grid.Where(c => c.Column == startCell.Column &&
                                c.Row >= startCell.Row &&
                                c.Row < startCell.Row + ship.Length);

            // Check if the selected cells are enough and if all are empty and isolated
            if (shipCells.Count() != ship.Length || shipCells.Any(c => !c.IsEmpty() || !IsCellIsolated(grid, c.Row, c.Column)))
                return false;

            // Place the ship if all checks passed
            foreach (var cell in shipCells)
            {
                cell.Ship = ship;
            }
            return true;
        }

        private bool IsCellIsolated(Grid grid, int row, int col)
        {
            // Use LINQ to find the neighbors by checking row and column offsets
            var neighbors = grid.Where(cell =>
                (cell.Row == row - 1 && cell.Column == col) ||    // Up
                (cell.Row == row + 1 && cell.Column == col) ||    // Down
                (cell.Row == row && cell.Column == col - 1) ||    // Left
                (cell.Row == row && cell.Column == col + 1));     // Right

            // Check if any neighbor cell is occupied
            return neighbors.All(cell => cell.IsEmpty());
        }

    }
}

================
File: SimpleMenu.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class SimpleMenu<T> : IMenu<T>
    {
        public readonly List<MenuItem<T>> _menuItems;
        public int _selectedIndex;
        public readonly int menuTop;

        public SimpleMenu(List<MenuItem<T>> items)
        {
            _menuItems = items;
            _selectedIndex = 0;
            menuTop = Console.CursorTop;
        }

        public void Draw()
        {
            Console.CursorVisible = false;

            // Clear only the lines used by the menu
            for (int i = 0; i < _menuItems.Count; i++)
            {
                Console.SetCursorPosition(0, menuTop + i);
                Console.Write(new string(' ', Console.WindowWidth));
            }

            // Draw menu with arrow for selected item
            for (int i = 0; i < _menuItems.Count; i++)
            {
                Console.SetCursorPosition(0, menuTop + i);
                if (i == _selectedIndex)
                {
                    Console.WriteLine($"-> {_menuItems[i].Text.PadRight(10)}");
                }
                else
                {
                    Console.WriteLine($"   {_menuItems[i].Text.PadRight(10)}");
                }
            }
        }

        public void Up()
        {
            if (_selectedIndex > 0)
            {
                _menuItems[_selectedIndex].IsSelected = false;
                _selectedIndex--;
                _menuItems[_selectedIndex].IsSelected = true;
                Draw();
            }
        }

        public void Down()
        {
            if (_selectedIndex < _menuItems.Count - 1)
            {
                _menuItems[_selectedIndex].IsSelected = false;
                _selectedIndex++;
                _menuItems[_selectedIndex].IsSelected = true;
                Draw();
            }
        }
        public T GetSelectedItem()
        {
            return _menuItems[_selectedIndex].Value;
        }
    }
}
