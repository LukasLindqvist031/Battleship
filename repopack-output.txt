This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-28T00:34:34.246Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.gitattributes
.gitignore
Attack.cs
Battleship.csproj
Battleship.sln
Cell.cs
Computer.cs
GameController.cs
GameSetup.cs
Grid.cs
Human.cs
HumanCreater.cs
IMenu.cs
IntelligentShooting.cs
IPlayerAction.cs
IShipPlacement.cs
IShootingStrategy.cs
MenuItem.cs
Player.cs
Program.cs
RandomShooting.cs
Repair.cs
Ship.cs
ShipPlacementService.cs
SimpleMenu.cs

================================================================
Repository Files
================================================================

================
File: .gitattributes
================
###############################################################################
# Set default behavior to automatically normalize line endings.
###############################################################################
* text=auto

###############################################################################
# Set default behavior for command prompt diff.
#
# This is need for earlier builds of msysgit that does not have it on by
# default for csharp files.
# Note: This is only used by command line
###############################################################################
#*.cs     diff=csharp

###############################################################################
# Set the merge driver for project and solution files
#
# Merging from the command prompt will add diff markers to the files if there
# are conflicts (Merging from VS is not affected by the settings below, in VS
# the diff markers are never inserted). Diff markers may cause the following 
# file extensions to fail to load in VS. An alternative would be to treat
# these files as binary and thus will always conflict and require user
# intervention with every merge. To do so, just uncomment the entries below
###############################################################################
#*.sln       merge=binary
#*.csproj    merge=binary
#*.vbproj    merge=binary
#*.vcxproj   merge=binary
#*.vcproj    merge=binary
#*.dbproj    merge=binary
#*.fsproj    merge=binary
#*.lsproj    merge=binary
#*.wixproj   merge=binary
#*.modelproj merge=binary
#*.sqlproj   merge=binary
#*.wwaproj   merge=binary

###############################################################################
# behavior for image files
#
# image files are treated as binary by default.
###############################################################################
#*.jpg   binary
#*.png   binary
#*.gif   binary

###############################################################################
# diff behavior for common document formats
# 
# Convert binary document formats to text before diffing them. This feature
# is only available from the command line. Turn it on by uncommenting the 
# entries below.
###############################################################################
#*.doc   diff=astextplain
#*.DOC   diff=astextplain
#*.docx  diff=astextplain
#*.DOCX  diff=astextplain
#*.dot   diff=astextplain
#*.DOT   diff=astextplain
#*.pdf   diff=astextplain
#*.PDF   diff=astextplain
#*.rtf   diff=astextplain
#*.RTF   diff=astextplain

================
File: .gitignore
================
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Oo]ut/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd

================
File: Attack.cs
================
using System;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Attack : IPlayerAction
    {
        public string Name { get; } = "Attack";

        private Grid _opponentGrid;
        private Cell _targetCell;

        public Attack(Grid opponentGrid)
        {
            _opponentGrid = opponentGrid;
        }

        public void Execute(Player player, Cell targetCell)
        {
            if (targetCell.IsHit)
            {
                Console.WriteLine("This cell has already been hit."); //Gör vi så att man får välja en ny cell här eller vad händer?
                return;
            }

            targetCell.IsHit = true;

            if (!(targetCell.IsEmpty()))
            {
                Ship targetShip = _targetCell.Ship; //Dependecy Inejction
                targetShip.HitTaken++;
                targetCell.Mark = "X ";



                if (targetShip.IsSunk()) //För att få vinn vilkoret att fungera måste vi tagit bort skepp som blivit nedskjutna
                {
                    player.RemoveSunkShip(targetShip);
                }
            }
            else { targetCell.Mark = "M "; }
        }
    }
}

================
File: Battleship.csproj
================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

================
File: Battleship.sln
================
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.11.35327.3
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Battleship", "Battleship.csproj", "{19741242-26BF-494E-A93F-0B645421CDD1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{19741242-26BF-494E-A93F-0B645421CDD1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{19741242-26BF-494E-A93F-0B645421CDD1}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{19741242-26BF-494E-A93F-0B645421CDD1}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{19741242-26BF-494E-A93F-0B645421CDD1}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {52D39088-333C-4BDA-A01B-1E8E1872AA0D}
	EndGlobalSection
EndGlobal

================
File: Cell.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Cell
    {
        public int Row { get; set; }
        public int Column { get; set; }
        public string Mark { get; set; }   
        public Ship Ship { get; set; } //Refers to a ship if there is one.
        public bool IsHit { get; set; } //Checks to see if the cell has been hit.

        public Cell(int row, int column)
        {
            Row = row;
            Column = column;
            Mark = "~ ";
            IsHit = false;
        }

        public bool IsEmpty() //Method to check if the cell is empty (no ship).
        {
            return Ship == null;
        }

        public bool HasShip() {  return Ship != null; }
    }
}

================
File: Computer.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Computer : Player
    {
        public Computer(
            string name,
            Grid playerGrid,
            Grid opponentGrid,
            List<Ship> ships,
            List<IPlayerAction> actions,
            IShootingStrategy shootingStrategy
             )
            : base(name, playerGrid, opponentGrid, ships, actions, shootingStrategy)
        {
        }
    }
}

================
File: GameController.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class GameController
    {
        private readonly Player _humanPlayer;
        private readonly Player _computerPlayer;
        private Player _currentPlayer;
        private bool _isGameOver;

        public GameController(Player humanPlayer, Player computerPlayer)
        {
            _humanPlayer = humanPlayer;
            _computerPlayer = computerPlayer;
            _currentPlayer = humanPlayer; // Human goes first
            _isGameOver = false;
        }
        public Player GetCurrentPlayer()
        {
            return _currentPlayer;
        }

        public Player GetOpponent()
        {
            return _currentPlayer == _humanPlayer ? _computerPlayer : _humanPlayer;
        }

        private void DisplayGameState()
        {
            Console.Clear();
            Console.WriteLine($"\n{_currentPlayer.Name}'s turn");

            if (_currentPlayer == _humanPlayer)
            {
                Console.WriteLine("\nYour Grid:");
                DisplayGrid(_humanPlayer.PlayerGrid, true);

                Console.WriteLine("\nOpponent's Grid:");
                DisplayGrid(_humanPlayer.OpponentGrid, false);
            }
        }

        private void DisplayGrid(Grid grid, bool showShips)
        {
            Console.WriteLine("  A B C D E F G H I J");
            for (int row = 0; row < 10; row++)
            {
                Console.Write((row + 1).ToString().PadLeft(2) + " ");
                for (int col = 0; col < 10; col++)
                {
                    var cell = grid.Grids[row, col];
                    char symbol = GetCellSymbol(cell, showShips);
                    Console.Write($"{symbol} ");
                }
                Console.WriteLine();
            }
        }

        private char GetCellSymbol(Cell cell, bool showShips)
        {
            if (cell.IsHit)
            {
                return cell.HasShip() ? 'X' : 'O';
            }

            if (showShips && cell.HasShip())
            {
                return 'S';
            }

            return '~';
        }

        private IPlayerAction GetHumanAction(List<IPlayerAction> availableActions)
        {
            while (true)
            {
                Console.WriteLine("\nAvailable Actions:");
                for (int i = 0; i < availableActions.Count; i++)
                {
                    Console.WriteLine($"{i + 1}. {availableActions[i].Name}");
                }

                Console.Write("\nSelect action (enter number): ");
                if (int.TryParse(Console.ReadLine(), out int choice) &&
                    choice >= 1 &&
                    choice <= availableActions.Count)
                {
                    return availableActions[choice - 1];
                }

                Console.WriteLine("Invalid selection. Please try again.");
            }
        }

        private IPlayerAction GetComputerAction(List<IPlayerAction> availableActions)
        {
            // For now, computer always chooses to attack if possible
            var attackAction = availableActions.FirstOrDefault(a => a is Attack); //LLM generated code. Kommentera/källhänvisa på nåt sätt, idk???
            return attackAction ?? availableActions.First();
        }

        private void CheckGameOver()
        {
            bool humanShipsDestroyed = _humanPlayer.AreAllShipsSunk();
            bool computerShipsDestroyed = _computerPlayer.AreAllShipsSunk();

            if (humanShipsDestroyed || computerShipsDestroyed)
            {
                _isGameOver = true;
                _currentPlayer = humanShipsDestroyed ? _computerPlayer : _humanPlayer; // Set winner as current player
            }
        }

        private void SwitchPlayer()
        {
            _currentPlayer = (_currentPlayer == _humanPlayer) ? _computerPlayer : _humanPlayer;
        }

        private void DisplayGameOver() //LLM. Nödväntigt att kommentera?
        {
            Console.Clear();
            Console.WriteLine("\n=== Game Over ===");
            Console.WriteLine($"\nWinner: {_currentPlayer.Name}!");

            // Display final grid states
            Console.WriteLine("\nFinal Grid States:");
            Console.WriteLine("\nPlayer's Grid:");
            DisplayGrid(_humanPlayer.PlayerGrid, true);
            Console.WriteLine("\nComputer's Grid:");
            DisplayGrid(_computerPlayer.PlayerGrid, true);

            Console.WriteLine("\nPress any key to exit...");
            Console.ReadKey();
        }
    }
}

================
File: GameSetup.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class GameSetup
    {
        private readonly ShipPlacementService _shipPlacementService;

        public GameSetup()
        {
            _shipPlacementService = new ShipPlacementService();
        }
        private string GetPlayerName()
        {
            Console.WriteLine("Welcome to Battleship!");
            Console.Write("Enter your name: ");
            string name = Console.ReadLine()?.Trim() ?? "Player";
            return string.IsNullOrEmpty(name) ? "Player" : name;
        }

        private IShootingStrategy SelectComputerStrategy()
        {
            var strategies = new List<MenuItem<IShootingStrategy>>
        {
            new MenuItem<IShootingStrategy>("Random Strategy", new RandomShooting()),
            new MenuItem<IShootingStrategy>("Intelligent Strategy", new IntelligentShooting()),
        };

            var menu = new SimpleMenu<IShootingStrategy>(strategies);
            

            while (true)
            {
                //Console.WriteLine("\nSelect computer's strategy:");
                menu.Draw();
                var key = Console.ReadKey(true);

                switch (key.Key)
                {
                    case ConsoleKey.UpArrow:
                        menu.Up();
                        break;
                    case ConsoleKey.DownArrow:
                        menu.Down();
                        break;
                    case ConsoleKey.Enter:
                        return menu.GetSelectedItem().Value;
                }
            }
        }


        public void Run()
        {
            // Welcome to Battleship! Press Enter to continue
            // What's your name? 
            // Select a strategy for the computer
            // Create Human and Computer
            // Start playing by selecting a square
            //Menu will be implemented among other places, in ShootingStrategy for Human in his UserShootingStrategy

            Console.Clear();
            string playerName = GetPlayerName();
            Console.Clear();
            IShootingStrategy computerStrategy = SelectComputerStrategy();
            

            Grid playerGrid = new Grid();
            Grid computerGrid = new Grid();

            var playerActions = new List<IPlayerAction> //Code reuse
            {
                new Attack(computerGrid),
                new Repair()
            };
            var computerActions = new List<IPlayerAction>
            {
                new Attack(playerGrid),
                new Repair()
            };

            var playerShips = new List<Ship> //Code Reuse? Reference type? 
            {
                new Ship(5), 
                new Ship(4), 
                new Ship(3), 
                new Ship(3), 
                new Ship(2)  
            };

            var computerShips = new List<Ship>
            {
                new Ship(5),
                new Ship(4),
                new Ship(3),
                new Ship(3),
                new Ship(2)
            };

            foreach (var ship in playerShips)
            {
                _shipPlacementService.PlaceShipRandomly(playerGrid, ship);
            }
            foreach (var ship in computerShips)
            {
                _shipPlacementService.PlaceShipRandomly(computerGrid, ship);
            }




            var human = new Human(
            name: playerName,
            playerGrid: playerGrid,
            opponentGrid: computerGrid,
            ships: playerShips,
            actions: playerActions,
            shootingStrategy: new RandomShooting()
            );

            var computer = new Computer(
                name: "Computer",
                playerGrid: computerGrid,
                opponentGrid: playerGrid,
                ships: computerShips,
                actions: computerActions,
                shootingStrategy: new RandomShooting()
            );

            var gameController = new GameController(human, computer);
            RunGameLoop(gameController);
        }

        private void RunGameLoop(GameController gameController)
        {
            bool gameOver = false;
            while (!gameOver)
            {
                Player currentPlayer = gameController.GetCurrentPlayer();
                Console.Clear();

                if(currentPlayer is Human)
                {
                    DisplayGameState(currentPlayer, gameController);
                    HandleHumanTurn(currentPlayer);
                }
            }
        }
        private void DisplayGameState(Player player, GameController gameController)
        {
            Console.WriteLine($"{player.Name}'s Grid:");
            DisplayGrid(player.PlayerGrid, true);  // Show ships for player grid

            Console.WriteLine($"\n{gameController.GetOpponent().Name}'s Grid:");
            DisplayGrid(player.OpponentGrid, false);  // Hide ships on opponent grid
        }

        private void DisplayGrid(Grid grid, bool showShips) //Update the mark for the cell, print the cell.mark instead
        {
            Console.Write("  ");
            for (int i = 0; i < Grid.GridSize; i++)
            {
                Console.Write($"{(char)('A' + i)} ");
            }
            Console.WriteLine();

            for (int row = 0; row < Grid.GridSize; row++)
            {
                Console.Write($"{row + 1}".PadLeft(2) + " ");  
                for (int col = 0; col < Grid.GridSize; col++)
                {
                    var cell = grid.Grids[row, col];
                    if (cell.IsHit)
                    {
                        Console.Write(cell.HasShip() ? "X " : "• ");  
                    }
                    else if (showShips && cell.HasShip())
                    {
                        Console.Write("O ");  
                    }
                    else
                    {
                        Console.Write("~ ");  
                    }
                }
                Console.WriteLine();
            }
        }

        private void HandleHumanTurn(Player currentplayer)
        {
            var menuItem = new List<MenuItem<IPlayerAction>>
            {
                new MenuItem<IPlayerAction>("Attack", currentplayer.Actions[0]),
                new MenuItem<IPlayerAction>("Repair", currentplayer.Actions[1])
            };

            var menu = new SimpleMenu<IPlayerAction>(menuItem);
            bool validAction = false;

            while (!validAction)
            {
                //Console.WriteLine("\n Choose your action:");

                menu.Draw();

                var key = Console.ReadKey(true);
                switch (key.Key)
                {
                    case ConsoleKey.UpArrow:
                        menu.Up();
                        break;
                    case ConsoleKey.DownArrow:
                        menu.Down();
                        break;
                    case ConsoleKey.Enter:
                        var selectedItem = menu.GetSelectedItem();
                        var action = selectedItem.Value;

                        if(action is Attack attack)
                        {
                            Cell targetCell = GetTargetCell(currentplayer.OpponentGrid);

                            attack.Execute(currentplayer, targetCell);
                            validAction = true;
                            //Add code here, for the user to be able to attack
                        }
                        else if (action is Repair repair)
                        {

                        }

                        break;
                }
            }
        }

        private Cell GetTargetCell(Grid opponentGrid)
        {
            int row = 0, col = 0;
            bool validInput = false;

            while (!validInput)
            {
                Console.WriteLine("\nEnter target coordinates:");
                Console.Write("Row (0-" + (Grid.GridSize - 1) + "): ");
                if (int.TryParse(Console.ReadLine(), out row))
                {
                    Console.Write("Column (0-" + (Grid.GridSize - 1) + "): ");
                    if (int.TryParse(Console.ReadLine(), out col))
                    {
                        if (row >= 0 && row < Grid.GridSize && col >= 0 && col < Grid.GridSize)
                        {
                            validInput = true;
                        }
                    }
                }
                if (!validInput)
                {
                    Console.WriteLine("Invalid coordinates. Please try again.");
                }
            }
            return opponentGrid.Grids[row, col];
        }
    }
}

================
File: Grid.cs
================
using System;

namespace Battleship
{
    public class Grid
    {
        public const int GridSize = 10; 
        public Cell[,] Grids { get; set; } 

        public Grid()
        {
            Grids = new Cell[GridSize, GridSize]; 
            for (int row = 0; row < GridSize; row++)
            {
                for (int col = 0; col < GridSize; col++)
                {
                    Grids[row, col] = new Cell(row, col); 
                }
            }
        }

        public static void DisplayGrid(Grid grid) //Död kod atm
        {
            Console.WriteLine("   A B C D E F G H I J");
            for (int row = 0; row < GridSize; row++) {
                Console.Write((row + 1).ToString().PadLeft(2) + " ");

                for (int col = 0; col < GridSize; col++)
                {
                    Console.Write(grid.Grids[row, col].Mark);
                }
                Console.WriteLine();
            }
        }

        public void PlaceTestShip(int row, int col)
        {
            if (!IsValidCoordinate(row, col))
            {
                Console.WriteLine("Invalid coordinates. Please enter values between 1 and " + GridSize);
                return;
            }

            Grids[row - 1, col - 1].Ship = new Ship(3);
        }

        public void ShootTest(int row, int col)
        {
            if (!IsValidCoordinate(row, col))
            {
                Console.WriteLine("Invalid coordinates. Please enter values between 1 and " + GridSize);
                return;
            }

            Grids[row - 1, col - 1].IsHit = true;
        }

        private bool IsValidCoordinate(int row, int col)
        {
            return row >= 1 && row <= GridSize && col >= 1 && col <= GridSize;
        }
    }
}

================
File: Human.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Human : Player
    {
        public Human(
            string name,
            Grid playerGrid,
            Grid opponentGrid,
            List<Ship> ships,
            List<IPlayerAction> actions,
            IShootingStrategy shootingStrategy
            )
            : base(name, playerGrid, opponentGrid, ships, actions, shootingStrategy)
        {
        }
    }
}

================
File: HumanCreater.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    internal class HumanCreater
    {
    }
}

================
File: IMenu.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IMenu<T>
    {
        void Draw();
        void up();
        void down();

        T GetSelectedItem();
    }
}

================
File: IntelligentShooting.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class IntelligentShooting : IShootingStrategy
    {
        private readonly Random _random;
        private List<Cell> _hitCells;  // Lista över träffade celler
        private Queue<Cell> _possibleTargets;  // Möjliga målceller runt ett träffat skepp

        public IntelligentShooting()
        {
            _random = new Random();
            _hitCells = new List<Cell>();
            _possibleTargets = new Queue<Cell>();
        }

        public void Shoot(Player player)
        {
            // Hämta motståndarens grid
            Grid opponentGrid = player.OpponentGrid;

            // Om vi har målceller att skjuta på (närliggande celler), välj från den kön
            if (_possibleTargets.Count > 0)
            {
                Cell targetCell = _possibleTargets.Dequeue(); // Hämta nästa cell från kön (Dequeue removes and returns the object at the beginning of the Queue<Cell>).

                // Om cellen redan har blivit träffad, välj en ny cell
                if (targetCell.IsHit)
                {
                    Shoot(player); // Skjut igen
                    return;
                }

                ExecuteAttack(player, targetCell);
            }
            else
            {
                // Annars, välj en slumpmässig cell om det inte finns några närliggande mål
                Cell targetCell = IsValidShoot(opponentGrid);
                ExecuteAttack(player, targetCell);
            }
        }

        private void ExecuteAttack(Player player, Cell targetCell)
        {
            Attack attack = new Attack(player.OpponentGrid);
            attack.Execute(player, targetCell);

            if (!targetCell.IsEmpty() && targetCell.IsHit)  // Om träff på skepp
            {
                _hitCells.Add(targetCell);  // Lägg till i listan med träffar

                // Lägg till möjliga målceller (upp, ner, vänster, höger)
                AddAdjacentCellsToTargets(player.OpponentGrid, targetCell);
            }
        }

        private void AddAdjacentCellsToTargets(Grid opponentGrid, Cell cell)
        {
            int row = cell.Row;
            int col = cell.Column;

            // Lägg till de 4 närliggande cellerna om de är giltiga skottmål
            if (row > 0 && !opponentGrid.Grids[row - 1, col].IsHit) // Upp
                _possibleTargets.Enqueue(opponentGrid.Grids[row - 1, col]); //(Enqueue adds an object to the end of the Queue<Cell>).

            if (row < Grid.GridSize - 1 && !opponentGrid.Grids[row + 1, col].IsHit) // Ner
                _possibleTargets.Enqueue(opponentGrid.Grids[row + 1, col]);

            if (col > 0 && !opponentGrid.Grids[row, col - 1].IsHit) // Vänster
                _possibleTargets.Enqueue(opponentGrid.Grids[row, col - 1]);

            if (col < Grid.GridSize - 1 && !opponentGrid.Grids[row, col + 1].IsHit) // Höger
                _possibleTargets.Enqueue(opponentGrid.Grids[row, col + 1]);
        }

        // Denna metod returnerar en slumpmässig valid cell (samma som RandomShooting, kan man typ göra en egen class eller nått med denna så man slipper upprepa den?).
        private Cell IsValidShoot(Grid opponentGrid)
        {
            Cell targetCell;
            int row, col;

            do
            {
                row = _random.Next(0, Grid.GridSize);
                col = _random.Next(0, Grid.GridSize);
                targetCell = opponentGrid.Grids[row, col];
            }
            while (targetCell.IsHit);

            return targetCell;
        }
    }
}

================
File: IPlayerAction.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IPlayerAction
    {
        string Name { get; }
        void Execute(Player player, Cell targetCell); 
    }
}

================
File: IShipPlacement.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IShipPlacement
    {
        void PlaceShipRandomly(Grid grid, Ship ship);
    }
}

================
File: IShootingStrategy.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public interface IShootingStrategy
    {
        void Shoot(Player player);
    }
}

================
File: MenuItem.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class MenuItem<T>
    {
        public string Text { get; }
        public T Value { get; }
        public bool IsSelected { get; set; }

        public MenuItem(string text, T value)
        {
            Text = text;
            Value = value;
            IsSelected = false;
        }
    }
}

================
File: Player.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public abstract class Player 
    {
        public string Name { get; }
        public Grid PlayerGrid { get; }
        public Grid OpponentGrid { get; }
        public List<Ship> Ships { get; }
        public List<IPlayerAction> Actions { get; }
        private readonly IShootingStrategy _shootingStrategy;


        protected Player(
        string name,
        Grid playerGrid,
        Grid opponentGrid,
        List<Ship> ships,
        List<IPlayerAction> actions,
        IShootingStrategy shootingStrategy
        )
        {
            Name = name;
            PlayerGrid = playerGrid;
            OpponentGrid = opponentGrid;
            Ships = ships;
            Actions = new List<IPlayerAction> { new Attack(opponentGrid), new Repair() };
            _shootingStrategy = shootingStrategy;
            
        }
        public void RemoveSunkShip(Ship ship)
        {
            if (Ships.Contains(ship)) {  Ships.Remove(ship); }
        }

        public bool AreAllShipsSunk()
        {
            foreach (var ship in Ships)
            {
                if (!ship.IsSunk())
                {
                    return false; 
                }
            }
            return true; 
        }
        /*public void PerformAction(int actionIndex)
        {
            if (actionIndex >= 0 && actionIndex < Actions.Count)
            {
                Actions[actionIndex].Execute(this); // Execute the chosen action
            }
            else
            {
                throw new ArgumentOutOfRangeException("Invalid action index");
            }
        }

        public void PerformShooting()
        {
            ShootingStrategy.Shoot(this); // Use the injected shooting strategy
        }*/
    }
}

================
File: Program.cs
================
using Battleship;

GameSetup game = new GameSetup();
game.Run();

================
File: RandomShooting.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class RandomShooting : IShootingStrategy
    {
        private readonly Random _random;

        public RandomShooting()
        {
            _random = new Random();
        }

        public void Shoot(Player player)
        {
            // Get the opponent's grid
            Grid opponentGrid = player.OpponentGrid; // Assuming Player has an Opponent reference and Grid

            // Find a valid cell to shoot at
            Cell targetCell = IsValidShoot(opponentGrid);

            // Use Attack class to perform the shooting action
            Attack attack = new Attack(opponentGrid);
            attack.Execute(player, targetCell);
        }

        public Cell IsValidShoot(Grid opponentGrid)
        {
            Cell targetCell;
            int row, col;

            do
            {
                row = _random.Next(0, Grid.GridSize);
                col = _random.Next(0, Grid.GridSize);
                targetCell = opponentGrid.Grids[row, col];
            }
            while (targetCell.IsHit);

            return targetCell;
        }
    }
}

================
File: Repair.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Repair : IPlayerAction
    {
        public string Name { get; } = "Repair";
        public void Execute(Player player, Cell targetCell) //Redunacy. Kan använda null, men blir fucked
        {
            foreach (var ship in player.Ships)
            {
                if (!ship.IsSunk() && ship.HitTaken > 0)
                {
                    ship.HitTaken--; 
                }
            }
        }
    }
}

================
File: Ship.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class Ship
    {
        public int Length { get; set; }
        public List<Cell> PlacedOnCell { get; set; }
        public int HitTaken { get; set; }

        public Ship(int length)
        {
            Length = length;
            PlacedOnCell = new List<Cell>();
            HitTaken = 0; 
        }

        public bool IsSunk()
        {
            return HitTaken >= Length;
        }

        public void TakeHit()
        {
            HitTaken++;
        }
    }
}

================
File: ShipPlacementService.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.ExceptionServices;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class ShipPlacementService : IShipPlacement
    {
        private Random _random = new Random();

        public void PlaceShipRandomly(Grid grid, Ship ship) //Om det finns ett skepp på platsen, ska det skrivas ut ett O, det ska inte behövas ändras manuellt. ÄNDRA!
        {
            bool placed = false;

            while (!placed)
            {
                bool vertical = _random.Next(2) == 0;

                int startRow = _random.Next(vertical ? Grid.GridSize - ship.Length : Grid.GridSize);
                int startColumn = _random.Next(!vertical ? Grid.GridSize - ship.Length : Grid.GridSize);

                if (IsValidPlacement(grid, ship, startRow, startColumn, vertical))
                {
                    for (int i = 0; i < ship.Length; i++)
                    {
                        if (vertical)
                        {
                            grid.Grids[startRow + i, startColumn].Ship = ship;
                            grid.Grids[startRow + i, startColumn].Mark = "O "; //Dupplicering ändra senare
                        }
                        else
                        {
                            grid.Grids[startRow, startColumn + i].Ship = ship;
                            grid.Grids[startRow, startColumn + i].Mark = "O "; //Dupplicering ändra senare
                        }
                    }
                    placed = true; 
                }
            }
        }

        private bool IsValidPlacement(Grid grid, Ship ship, int startRow, int startCol, bool vertical)
        {
            for(int i = 0; i < ship.Length; i++)
            {
                int row = vertical ? startRow + i : startRow;
                int col = vertical ? startCol : startCol + i;

                if (row >= Grid.GridSize || col >= Grid.GridSize || !grid.Grids[row, col].IsEmpty() || !IsCellIsolated(grid, row, col))
                {
                    return false; 
                }
            }
            return true;
        }

        private bool IsCellIsolated(Grid grid, int row, int col)
        {
            if (row > 0 && !grid.Grids[row - 1, col].IsEmpty())
            {
                return false;
            }

            if (row < Grid.GridSize - 1 && !grid.Grids[row + 1, col].IsEmpty())
            {
                return false;
            }

            if (col > 0 && !grid.Grids[row, col - 1].IsEmpty())
            {
                return false;
            }

            if (col < Grid.GridSize - 1 && !grid.Grids[row, col + 1].IsEmpty())
            {
                return false;
            }
            return true;
        }
    }
}

================
File: SimpleMenu.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Battleship
{
    public class SimpleMenu<T>
    {
        private readonly List<MenuItem<T>> _menuItems;
        private int _selectedIndex;
        private readonly int menuTop;

        public SimpleMenu(List<MenuItem<T>> items)
        {
            _menuItems = items;
            _selectedIndex = 0;
            menuTop = Console.CursorTop;
            Console.CursorVisible = false; //Denna kod gör kanske resterande cursorposition onödig. Kontrollera! 
            if (_menuItems.Any())
            {
                _menuItems[0].IsSelected = true;
            }
        }

        public void Draw()
        {
            //Console.SetCursorPosition(0, menuTop);

            // Clear the menu 
            for (int i = 0; i < _menuItems.Count; i++)
            {
                Console.WriteLine(new string(' ', Console.WindowWidth));
            }

            // Move cursor back to start
            Console.SetCursorPosition(0, menuTop);

            for (int i = 0; i < _menuItems.Count; i++)
            {
                var item = _menuItems[i];

                // Fundera på om detta är värt det. Eller om det finns rimligare lösningar. Jämför med Pokemon spelet. 
                if (_selectedIndex == i)
                {
                    Console.WriteLine($"-> {item.Text.PadRight(10)}"); // Highlighted option
                }
                else
                {
                    Console.WriteLine($"   {item.Text.PadRight(10)}"); // Non-highlighted option with spaces for alignment
                }
            }
        }

        public void Up()
        {
            if (_selectedIndex > 0)
            {
                _menuItems[_selectedIndex].IsSelected = false;
                _selectedIndex--;
                _menuItems[_selectedIndex].IsSelected = true;
                Draw();
            }
        }

        public void Down()
        {
            if (_selectedIndex < _menuItems.Count - 1)
            {
                _menuItems[_selectedIndex].IsSelected = false;
                _selectedIndex++;
                _menuItems[_selectedIndex].IsSelected = true;
                Draw();
            }
        }
        public MenuItem<T> GetSelectedItem()
        {
            return _menuItems[_selectedIndex];
        }
    }
}
